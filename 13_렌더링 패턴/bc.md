# 13장 렌더링 패턴

웹 페이지는 제공하는 기능에 따라 정적일 수도, 동적일 수도 있습니다. 서버에서 생성하여 클라이언트에 그대로 전달하는 블로그/뉴스 페이지와 같은 정적인 콘텐츠는 여전히 웹에서 많이 사용됩니다. 따라서 정적 웹 페이지는 렌더링 후에 하이드레이션이 필요하지 않습니다.

**렌더링 패턴**

| **종류**              | **설명**                                                                    |
| ------------------- | ------------------------------------------------------------------------- |
| 클라이언트 사이드 렌더링 (CSR) | HTML이 클라이언트에서 완전히 렌더링됩니다.                                                 |
| 서버 사이드 렌더링(SSR)     | HTML 콘텐츠를 서버에서 동적으로 렌더링한 후, 클라이언트에서 하이드레이션 합니다.                           |
| 정적 렌더링              | 빌드 타임에 서버에서 페이지를 렌더링하여 정적인 사이트를 구축합니다.                                    |
| 점진적 정적 생성(ISR)      | 초기 빌드 이후에도 정적 사이트를 동적으로 추가하거나 수정할 수 있습니다.(Next.js ISR, Gatsby DSG)        |
| 스트리밍 SSR            | 서버에서 렌더링된 콘텐츠를 더 작은 스트림 조각으로 분할하여 전달합니다.                                  |
| 엣지 렌더링              | 렌더링된 HTML을 클라이언트에 전송하기 전에 엣지에서 수정합니다.                                     |
| 하이브리드 렌더링           | 빌드 타임, 서버 및 클라이언트 렌더링을 결합하여 웹 개발에 더 유연한 접근 방식을 제공합니다.(Next.js App Router) |
| 부분 하이드레이션           | 클라이언트에서 일부 컴포넌트만 하이드레이션 합니다.                                              |
| 점진적 하이드레이션          | 클라이언트에서 컴포넌트 하이드레이션 순서를 제어합니다.                                            |
| 아일랜드 아키텍처           | 정적인 사이트 내에 여러 진입점을 가진 동적인 동작의 격리된 영역을 만듭니다.                               |
| 점진적 향상              | 자바스크립트 없이도 애플리케이션이 작동하도록 보장합니다.                                           |

## 13.1 렌더링 패턴의 중요성

올바른 패턴을 선택하면 더 빠른 빌드 속도와 탁월한 로딩 성능을 낮은 처리 비용으로 얻을 수 있는 반면, 잘못된 패턴 선택은 훌륭한 비즈니스 아이디어를 실현할 수 있는 애플리케이션을 망칠 수도 있습니다.

- TTFB(Time to First Byte)
    
    - 클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는 데 걸리는 시간
        
- FCP(First Contentful Paint)
    
    - 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는 데 걸리는 시간
        
- TTI(Time to Interaction)
    
    - 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
        
- LCP(Largest Contentful Paint)
    
    - 페이지의 주요 콘텐츠를 로드하고 렌더링하는 데 걸리는 시간
        
- CLS(Cumulative Layout Shift)
    
    - 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
        
- FID(First Input Delay)
    
    - 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간
        

## 13.2 클라이언트 사이드 렌더링(CSR)

거의 모든 UI가 클라이언트에서 생성되며, 전체 웹 애플리케이션은 처음 요청 시에 모두 로드됩니다. 사용자가 링크를 클릭하여 탐색할 때 페이지 렌더링을 위한 새로운 요청을 서버로 보내지 않습니다. 대신 클라이언트에서 코드가 실행되어 뷰나 데이터를 갈아 끼웁니다.

새로 고침 없이 탐색을 지원하는 SPA를 구축할 수 있게 하여 뛰어난 사용자 경험을 제공합니다. 하지만, 이미지 표시, 데이터 저장소에서 데이터 가져오기, 이벤트 처리 등 페이지의 복잡성이 증가하면 페이지 렌더링에 필요한 자바스크립트 코드의 복잡성과 크기도 증가합니다. 또한 번들을 만들어 페이지의 FCP와 TTI을 증가시킵니다. 크롤러가 색인하기 전에 의미 있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있어 웹 사이트의 SEO에 영향을 미칠 수 있습니다.

## 13.3 서버 사이드 렌더링(SSR)

모든 요청마다 HTML을 생성합니다. 인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지에 적합합니다. SSR을 사용하면 데이터 fetching 및 템플릿 처리를 위한 추가적인 왕복 시간을 줄일 수 있습니다.  자바스크립트 코드를 클라이언트에 전송할 필요도 없습니다.

모든 요청이 독립적으로 처리되고, 서버에 의해 새로운 요청으로 간주됩니다. 연속된 두 요청의 결과가 크게 다르지 않더라도, 서버는 처음부터 다시 처리하고 HTML을 생성합니다.

하이드레이션은 서버 렌더링 후 클라이언트 사이드에서 UI 컴포넌트의 상태를 재생성하는 과정입니다. 비용이 따르기 때문에 언제나 하이드레이션 과정을 최적화하려고 합니다.

## 13.4 정적 렌더링

전체 페이지의 HTML을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않습니다. 정적인 HTML 콘텐츠는 CDN(Content Delivery Network)이나 엣지 네트워크에 쉽게 캐싱될 수 있습니다. 특정 페이지를 요청하면 미리 렌더링된 캐시된 HTML을 빠르게 제공할 수 있습니다.

- 데이터베이스의 동적 데이터를 활용한 리스트 페이지 정적 생성
    
    - 리스트 자체가 크게 동적이지 않은 페이지에 적합합니다. Nextjs에서 Page router의 경우, 페이지 컴포넌트 내에 getStaticProps() 함수를 내보내서 사용할 수 있습니다. App router의 경우에는 fetch의 cache 옵션을 사용하는 것으로 간소화 되었습니다.
        
- 동적 경로를 사용한 상세 페이지 정적 생성
    
    - 템플릿과 동적 데이터를 병합하여 서버에서 개별 페이지를 생성할 수 있으며, 각 상세 페이지마다 여러 개의 개별 경로를 갖게 됩니다.
        
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링
    
    - 항상 최신 목록을 표시해야 하는 동적인 리스트 페이지에 유용합니다. 페이지가 로드된 후 SWR을 사용하여 데이터를 가져옵니다. Stale-While-Revalidate 패턴에서 영감을 얻은 SWR은 클라이언트 사이드에서 데이터 fetching을 위한 리액트 Hook 라이브러리입니다.
        

### 13.4.1 점진적 정적 생성(ISR)

정적 렌더링과 SSR을 결합한 방식으로 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청 시에 on-demand 방식으로 렌더링합니다. 이렇게 하면 빌드 시간이 단축되며, 특정 시간 간격마다 캐시를 자동으로 무효화하고 페이지를 다시 생성할 수 있습니다.

- 새로운 페이지 추가 허용
    
    - 새로운 페이지는 첫 요청 즉시 생성됩니다. 생성되는 동안 사용자에게 대체 페이지(fallback)이나 로딩 화면을 보여줄 수 있습니다.
        
- 기존 페이지 업데이트
    
    - 페이지 재검증이 완료될 때까지 사용자는 이전 버전의 페이지를 계속 보게 됩니다. 따라서 ISR은 Stale-While-Revalidate 전략을 사용합니다. 즉, 재검증이 진행되는 동안 사용자는 캐시된 또는 이전 버전을 보게 됩니다.
        

### 13.4.2 On-demand ISR

정해진 시간 간격이 아니라, 특정 이벤트 발생 시에 페이지가 재생성됩니다. 엣지 네트워크 전체에 페이지를 다시 생성하고 재분배하므로 자동으로 전 세계 사용자가 캐시된 오래된 콘텐츠가 아닌 최신 버전의 페이지를 볼 수 있습니다. 또한, 불필요한 페이지 재생성과 서버리스 함수 호출을 피할 수 있어 일반 ISR에 비해 운영 비용을 절감할 수 있습니다.

## 13.5 스트리밍 SSR

자바스크립트 용량을 줄여 페이지가 상호 작용 가능해지는 시간(TTI)을 FCP에 더 가깝게 만들 수 있습니다. 애플리케이션을 서버에서 렌더링하면서도  TTI와 FCP는 더욱 단축할 수 있습니다. 현재 페이지에 필요한 마크업을 모두 담은 큰 HTML 파일 하나를 생성하는 대신 작은 청크로 나눠서 전송하는 것입니다.

- ReactDOMServer.renderToNodeStream()
    
    - 문자열 대신 Node.js의 ReadableStream 형식을 사용합니다. 서버에서만 작동하여 HTML을 스트리밍으로 렌더링합니다. 이 스트리밍을 받는 클라이언트는 ReactDOM.hydrate()를 호출하여 페이지를 하이드레이션하고, 상호 작용이 가능하게 만들 수 있습니다.
        
- ReactDOMServer.renderToStaticNodeStream()
    
    - 만들어지는 HTML 결과물은 동일하지만 스트림 형식입니다. 따라서 서버에서 정적이고 비상호 작용적인 페이지를 렌더링한 다음 클라이언트에 스트리밍하는 데 사용할 수 있습니다.
        

## 13.6 엣지 SSR

엣지 SSR은 CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트 시간을 거의 0에 가깝게 줄여줍니다. HTTP 스트리밍도 지원하므로 준비되는 즉시 문서의 일부를 스트리밍하고 각 컴포넌트를 세밀하게 하이드레이션하여 FCP 시간을 단축합니다.

## 13.7 하이브리드 렌더링

어떤 상황에서든 최적의 결과를 제공하기 위해 여러 가지 렌더링 방식을 결합합니다. 하이브리드 렌더링은 기존 용어(SPA, MPA, SSR, SSG)들이 가진 틀을 깨는 새로운 접근 방식이며, 최신 웹 개발 패러다임을 더 잘 설명하기 위한 새로운 용어의 필요성을 강조합니다. 정적 렌더링 및 클라이언트 사이드 렌더링으로 시작했다가 나중에 필요할 때 페이지 별로 서버 사이드 렌더링을 추가하는 모습을 주로 보입니다.

## 13.8 점진적 하이드레이션

각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식입니다. 페이지의 상대적으로 덜 중요한 부분의 하이드레이션을 지연시켜 페이지를 상호 작용할 수 있게 만드는 데 필요한 자바스크립트 양을 줄이고 사용자에게 필요한 노드만 하이드레이션할 수 있습니다.

- 모든 컴포넌트에 SSR 사용 가능
    
- 개별 컴포넌트 또는 조각 단위로 코드 스플리팅 지원
    
- 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각별 하이드레이션 지원
    
- 이미 하이드레이션 된 조각이서 사용자 입력 가능 상태 유지
    
- 지연된 하이드레이션이 적용되는 조각에 로딩 중임을 표시 가능
    

리액트의 동시성 모드(Concurrent Mode) 기능이 도입되면 이러한 요구 사항을 모두 충족할 수 있습니다. 사용자 입력과 같은 더 높은 우선순위의 작업이 필요하며 리액트는 하이드레이션 작업을 일시 중지하고 사용자 입력을 받아들이는 작업으로 전환합니다.

## 13.9 아일랜드 아키텍처

정적인 HTML 위에 독립적으로 전달될 수 있는 상호 작용 아일랜드를 통해 자바스크립트의 전송량을 줄이는 패러다임을 의미합니다.

아일랜드 아키텍처는 점진적 하이드레이션과 혼동될 수 있지만, 뚜렷한 차이점이 있습니다. 점진적 하이드레이션에서는 페이지의 하이드레이션 구조가 하향식입니다. 즉 페이지가 개별 컴포넌트의 스케줄링 및 하이드레이션을 제어합니다. 반면, 아일랜드 아키텍처에서는 각 컴포넌트가 자체적으로 하이드레이션 스크립트를 갖고 있으며, 이 스크립트는 페이지의 다른 스크립트와 독립적으로 비동기 실행됩니다.

## 13.10 리액트 서버 컴포넌트

RSC는 서버에서 실행되도록 설계된 상태를 가지지 않는 리액트 컴포넌트로 서버 주도 방식으로 현대적인 사용자 경험을 제공하는 것을 목표로 합니다. 번들 크기를 0으로 줄이고, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험, 즉 니팅(knitting)을 가능하게 합니다.

RSC 프로토콜을 사용하면 서버는 클라이언트가 컴포넌트 트리의 일부를 요청할 수 있는 특별한 엔드포인트를 제공하여 MPA와 유사한 아키텍처로 SPA와 같은 라우팅을 가능하게 합니다. 이를 통해 상태의 변경 없이 서버 컴포넌트 트리와 클라이언트 사이드 트리를 병합하고 더 많은 컴포넌트로 확장할 수 있습니다.

SSR 인프라를 통해 HTML로 변환하여 초기 렌더링 속도를 빠르게 유지할 수 있는 장점이 있습니다.
