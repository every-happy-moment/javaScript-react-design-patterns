# 13_렌더링 패턴
렌더링 패턴
- 클라이언트 사이드 렌더링(CSR): HTML이 클라이언트에서 완전히 렌더링된다.
- 서버 사이드 렌더링(SSR): HTML 콘텐츠를 서버에서 동적으로 렌더링한 후, 클라이언트에서 하이드레이션한다.
- 정적 렌더링(Static Rendertin): 빌드 타임에 서버에서 페이지를 렌더링하여 정적인 사이트를 구축한다.
- 점진적 정적 생성(ISR): 초기 빌드 이후에도 정적 사이트를 동적으로 추가하거나 수정할 수 있다.
- 스트리밍 SSR(Streaming SSR): 서버에서 렌더링된 콘텐츠를 더 작은 스트림 조각으로 분할하여 전송한다.
- 엣지 렌더링(Edge Rendering): 렌더링된 HTML을 클라이언트에 전송하기 전에 엣지에서 수정한다.
- 하이브리드 렌더링(Hybrid Rendering): 빌드 타임, 서버 및 클라이언트 렌더링을 결합하여 웹 개발에 더 유연한 접근 방식을 제공한다.
- 부분 하이드레이션(Partial Hydration): 클라이언트에서 일부 컴포넌트만 하이드레이션한다.
- 점진적 하이드레이션(Progressive Hydration): 클라이언트에서 컴포넌트 하이드레이션 순서를 제어한다.
- 아일랜드 아키텍처: 정적인 사이트 내에 여러 진입점을 가진 동적인 동작의 격리된 영역을 만든다.
- 점진적 향상(Progressive Enhancement): 자바스크립트 없이도 애플리케이션이 작동하도록 보장한다.

## 13.1 렌더링 패턴의 중요성
주어진 상황에 가장 적합한 렌더링 패턴을 선택하는 것은 개발 경험(DX)과 사용자 경험(UX)에 엄청난 차이를 만들 수 있다.<br />
뛰어난 사용자 경험을 제공하기 위해서는, 핵심 웹 지표(Core Web Vitals(CWV))와 같은 사용자 중심 시표를 기준으로 애플리케이션을 최적화해야 한다.
- TTFB(Time to First Byte): 클라이언트가 페이지 콘텐츠의 첫 번째 바이트를 받는데 걸리는 시간
- FCP(First Contentful Paint): 페이지 이동 후 브라우저가 콘텐츠의 첫 부분을 렌더링하는데 걸리는 시간
- TTI(Time to Interactive): 페이지 로드 시작부터 사용자 입력에 빠르게 응답할 수 있을 때까지 걸리는 시간
- LCP(Largest Contentful Paint): 페이지의 주요 콘텐츠를 로드하고 렌더링하는데 걸리는 시간
- CLS(Cumulative Layout Shift): 예상치 못한 레이아웃 변경을 방지하기 위한 시각적 안정성 측정
- FID(First Input Delay): 사용자가 페이지와 상호작용한 시점부터 이벤트 핸들러가 실행될 수 있는 시점까지의 시간

## 13.2 클라이언트 사이드 렌더링(CSR)
리액트의 CSR에서는 대부분의 애플리케이션 로직이 클라이언트에서 실행되며, 데이터를 가져오거나 저장하기 위한 API 호출로 서버와 상호작용한다. 따라서 거의 모든 UI가 클라이언트에서 생성되며, 전체 웹 애플리케이션은 처음 요청시에 모두 로드된다. 사용자가 링크를 클릭하여 탐샐할 때 페이지 렌더링을 위한 새로운 요청을 서버로 보내지 않는다. 대신 클라이어트에서 코드가 실행되어 뷰나 데이터를 갈아끼운다.<br />
CSR은 페이지 새로고침 없이 탐색을 지원하는 SPA를 구축할 수 있게 하여 뛰어난 사용자 경험을 제공한다.<br />
CSR은 큰 자바스크립트 번들을 만들도록 하여 페이지의 FCP(First Contentful Paint)와 TTI(Time to Interactive)를 증가시킨다. 또한 큰 요청 객체와 API 응답과 같은 일련의 네트워크 요청으로 인해, 크롤러가 색인하기 전에 의미있는 콘텐츠가 시간에 맞춰 렌더링되지 않을 수 있어 웹사이트의 SEO에 영향을 미칠 수 있다.

## 13.3 서버 사이드 렌더링(SSR)
SSR은 모든 요청마다 HTML을 생성한다. 이 방식은 사용자 쿠키 정보나 요청 데이터를 기반으로 하는 등, 개인 맞춤형 데이터를 포함하는 페이지에 가장 적합하다. 인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지에도 적합하다.<br />
SSR은 가장 오래된 웹 콘텐츠 렌더링 방식 중 하나로, 사용자 요청에 대한 응답으로 렌더링 할 페이지 콘텐츠의 전체 HTML을 서버에서 생성한다.<br />
SSR에서는 데이터 연결 및 fetching 작업이 서버에서 처리된다. 콘텐츠 형식 지정에 필요한 HTML 또한 서버에서 생성된다.<br />
SSR의 핵심 원칙은 HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는데 필요한 자바스크립트를 함께 제공하는 것이다. 하이드레이션은 서버 렌더링 후 클라이언트 사이드에서 UI 컴포넌트의 상태를 재생성하는 과정이다. 하이드레이션에는 비용이 따르기 때문에, SSR은 언제나 하이드레이션 과정을 최적화하려고 한다.

## 13.4 정적 렌더링
정적 렌더링(Static Rendering)은 전체 페이지의 HTML을 빌드 시점에 미리 생성하며, 다음 빌드 때까지 변경되지 않는다. 이 정적인 HTML 콘텐츠는 CDN(Cntent Delivery Network)이나 엣지 네트워크에 쉽게 캐싱될 수 있다.<br />
정적 렌더링 방식은 자주 변경되지 않고 누가 요청하든 동일한 데이터를 표시하는 페이지에 가장 적합하다.<br />
클라이언트 사이드 데이터 fetching을 통한 정적 렌더링은 매 페이지 로드시 새로고침되어야 하고 안정적인 placeholder 컴포넌트에 포함된 데이터가 있는 페이지에 가장 적합하다.

### 13.4.1 점진적 정적 생성(ISR)
점진적 정적 생성(Incremental Static Regeneratino(ISR))은 정적 렌더링과 SSR을 결합한 방식으로, 특정 정적 페이지만 미리 렌더링하고 동적 페이지는 사용자 요청시에 on-demand 방식으로 렌더링한다. 이렇게 하면 빌드 시간이 단축되며, 특정 시간 간격마다 캐시를 자동으로 무효화하고 페이지를 다시 생성할 수 있다.

### 13.4.2 On-demand ISR
On-demand ISR은 일반 ISR과 달리, 정해진 시간 간격이 아니라 특정 이벤트 발생 시에 페이지가 재생성된다. 특정 이벤트에 따라 재생성되어야 하는 페이지에 On-demand ISR을 적용하면, 항상 최신 상태를 유지하면서도 합리적인 비용으로 빠르고 동적인 웹사이트를 운영할 수 있다.

### 13.4.3 정적 렌더링 요약
- 순수 정적 렌더링: 동적인 데이터가 포함되지 않는 페이지에 적합하다.
- 클라이언트 사이드 데이터 fetching을 통한 정적 렌더링: 매 페이지 로드시 데이터가 새로고침 되어야 햐고 안정적인 placeholder 컴포넌트를 가진 페이지에 적합하다.
- 점진적 정적 생성(ISR): 특정 간격 또는 필요에 따라 재생성되어야 하는 페이지에 적합하다.
- On-demand ISR: 특정 이벤트 발생시 재생성되어야 하는 페이지에 적합하다.

## 13.5 스트리밍 SSR
스트리밍 방식으로 콘텐츠를 전송하면 애플리케이션을 서버에서 렌더링하면서도 TTI와 FCP를 더욱 단축할 수 있다. 현재 페이지에 필요한 마크업을 모두 담은 큰 HTML 파일 하나를 생성하는 대신, 작은 조각(청크, chunk)으로 나눠서 전송하는 것이다.<br />
스트리밍은 네트워크 정체 현상에 효과적이다. 네트워크가 혼잡하여 더 이상 바이트를 전송할 수 없는 경우, 렌더러는 신호를 받아 네트워크가 해소될 때까지 스트리밍을 중단한다. 따라서 서버는 메모리를 덜 사용하고 I/O가 필요한 상황에 더욱 민첩하게 반응할 수 있다. 결과적으로, 열악한 환경에서도 사이트는 빠른 응답성을 유지할 수 있다.<br />
리액트는 2016년에 출시된 리액트 16 버전부터 스트리밍을 지원하기 시작했다. 스트리밍을 지원하기 위해 ReactDOMServer 에 다음과 같은 API가 포함되었다.
- ReactDOMServer.renderToNodeStram(element)
- ReactDOMServer.renderToStaticNodeStream(element)

## 13.6 엣지 SSR
엣지(Edge) SSR은 CDN의 모든 지역에서 서버 렌더링을 가능하게 하고, 콜드 부트 시간(함수가 처음 실행될 때 발생하는 지연 시간을 의미)을 거의 0에 가깝게 줄여준다.<br />
서버리스 함수를 사용하면 전체 페이지를 서버 사이드에서 생성할 수 있다. 엣지 런타임은 HTTP 스트리밍도 지원하므로, 준비되는 즉시 문서의 일부를 스트리밍하고 각 컴포넌트를 세밀하게 하이드레이션하여 FCP 시간을 단축한다.<br />
엣지 SSR의 활용 사례로는 사용자별로 지역 특화 리스트 페이지를 구축하는 것을 들 수 있다.

## 13.7 하이브리드 렌더링
하이브리드 렌더링은 어떤 상황에서든 최적의 결과를 제공하기 위해 여러 가지 렌더링 방식을 결합한다. 따라서 정적으로 제공될 수 있는 페이지는 미리 렌더링되고, 애플리케이션의 다른 페이지에는 동적인 전략을 선택할 수 있다.<br />
정적 렌더링 및 클라이언트 사이드 렌더링으로 시작했다가 나중에 필요할 때 페이지별로 서버 사이드 렌더링을 추가하는 모습을 주로 보인다.

## 13.8 점진적 하이드레이션
점진적 하이드레이션은 각 노드를 시간에 따라 개별적으로 하이드레이션하여 필요한 최소한의 자바스크립트만 요청하는 방식이다. 점진적 하이드레이션은 SSR에서 흔히 발생하는 서버에서 렌더링된 DOM 트리가 파괴되고 즉시 다시 생성되는 문제를 방지할 수 있다.<br />
점진적 하이드레이션은 애플리케이션을 여러 조각으로 나누어 뛰어난 성능을 제공하는 것을 목표로 한다.<br />
완전한 점진적 하이드레이션 구현을 위한 요구사항
- 모든 컴포넌트에 SSR 사용가능
- 개별 컴포넌트 또는 조각 단위로 코드 스플리팅 지원
- 개발자가 정의한 순서대로 클라이언트 사이드에서 각 조각별 하이드레이션 지원
- 이미 하이드레이션된 조각에서 사용자 입력 가능 상태 유지
- 지연된 하이드레이션이 적용되는 조각에 고딩 중임을 표시 기능
<br /><br />
리액트의 동시성 모드(concurrent mode) 기능이 도입되면 이러한 요구사항을 모두 충족할 수 있다. 동시성 모드는 여러 작업을 동시에 처리하면서도 우선순위에 따라 작업 간 전환을 가능하게 한다. 작업 전환시 부분적으로 렌더링된 트리는 진행을 잠시 멈추어, 다시 동일한 작업으로 돌아왔을 때 이전의 렌더링 작업을 계속할 수 있다.

## 13.9 아일랜드 아키텍처
아일랜드 아키텍처는 정적인 HTML 위에 독립적으로 전달될 수 있는 상호작용 아일랜드(islands of interactivity)를 통해 자바스크립트의 전송량을 줄이는 패러다임을 의미한다. 또한 아일랜드 아키텍처는 컴포넌트 기반 아키텍처로, 정적 그리고 동적 아일랜드로 구분된 페이지 뷰를 제안한다.<br />
아일랜드 아키텍처는 점진적 하이드레이션과 혼동될 수 있지만, 뚜렷한 차이점이 있다. 점진적 하이드레이션에서는 페이지의 하이드레이션 구조가 하향식(top-down)이다. 반면, 아일랜드 아키텍처에서는 각 컴포넌트가 자체적으로 하이드레이션 스크립트를 가지고 있으며, 이 스크립트는 페이지의 다른 스크립트와 독립적으로 비동기 실행된다. 따라서 특정 컴포넌트의 성능 문제가 다른 컴포넌트에 영향을 주지 않는다.

### 13.9.1 아일랜드 아키텍처 구현하기
- Astro: Astro는 리액트, 스벨트, Preact, Vue.js 등 다른 프레임워크에서 만든 UI 컴포넌트를 사용하여 가벼운 정적 HTML 페이지를 생성할 수 있는 정적 사이트 빌더이다. 클라이언트 사이드 자바스크립트가 필요한 컴포넌트는 의존성과 함께 개별적으로 로드하기에 기본적으로 부분 하이드레이션을 제공한다. 또한 컴포넌트가 렌더링될 때까지의 지연 로딩을 지원한다.<br />
Astro는 처음부터 아일랜드 아키텍처를 기반으로 만들어졌기 때문에 기본적으로 아일랜드 아키텍처를 지원한다.

### 13.9.2 아일랜드 아키텍처의 장점과 단점
장점
- 성능
- SEO
- 중요 콘텐츠 우선순위
- 접근성
- 컴포넌트 기반
<br /><br />
단점
- 아일랜드 아키텍처는 아직 초기 단계에 머물러 있다. 아일랜드 아키텍처를 구현하려면 몇 안되는 프레임워크를 사용하거나 직접 아키텍처를 개발해야 한다.
- 아일랜드 아키텍처는 수천개의 아일랜드가 필요할 수 있는 소셜 미디어 애플리케이션과 같이 상호작용을 위주로 한 페이지에는 적합하지 않다.

## 13.10 리액트 서버 컴포넌트
리액트 서버 컴포넌트(React Server Component(RSC))는 서버에서 실행되도록 설계된, 상태를 가지지 않는 리액트 컴포넌트로, 서버 주도 방식으로 현대적인 사용자 경험을 제공하는 것을 목표로 한다. 이러한 컴포넌트들은 번들 크기를 0으로 줄이고, 서버 컴포넌트와 클라이언트 컴포넌트 사이의 매끄러운 코드 전환 경험, 즉 니팅(knitting)을 가능하게 한다. 이는 기존의 SSR 방식과 차별화되며, 결과적으로 클라이언트 사이드 자바스크립트 번들의 크기를 크게 줄일 수 있다.<br />
서버 컴포넌트는 SSR을 대체하지 않는다. 오히려 함께 사용하면 서버 컴포넌트 렌더링 초기 단계의 결과물을 빠르게 렌더링하고, SSR 인프라를 통해 HTML로 변환하여 초기 렌더링 속도를 빠르게 유지할 수 있다.<br />
Next.js는 App Router 기능을 통해 RSC를 지원하고 있는 데다 리액트 개발팀도 RSC가 결국 대중화되어 생태계를 변화시킬 것이라고 생각하고 있다.

### 13.10.1 RSC와 Next.js App Router를 활용한 하이브리드 렌더링
Next.js의 app 디렉토리 내의 컴포넌트는 기본적으로 RSC로 설정되어 있기에, 자동으로 서버 컴포넌트로 렌더링되고 성능이 향상된다.<br />
Next.js의 App Router는 서버 렌더링과 클라이언트 사이드 상호작용을 결합하여 점진적으로 애플리케이션을 향상시키고 매끄러운 사용자 경험을 제공한다.<br />
클라이언트 컴포넌트는 이전의 Next.js 12 버전에서 했던 것처럼 클라이언트 사이드의 상호작용 기능을 추가하기 위해 사용된다. 'use client' 지시문이 없는 컴포넌트는 다른 클라이언트 컴포넌트에 의해 import 되지 않는 한 자동으로 서버 컴포넌트로 렌더링된다. 
