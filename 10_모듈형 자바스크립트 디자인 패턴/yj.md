# 10_모듈형 자바스크립트 디자인 패턴

모듈형(modular)이란 서로 의존성이 낮은 기능들이 모듈로써 저장된 형태를 뜻한다. 이러한 느슨한 결합은 의존성을 제거하여 애플리케이션의 유지보수를 용이하게 만들어준다. 모듈을 적절하게 활용하다면 시스템 어느 한 부분의 변경이 다른 부분에 어떠한 영향을 미칠지 쉽게 파악할 수 있다.

## 10.1 스크립트 로더에 대한 참고사항
스크립트 로더는 모듈형 자바스크립트를 구현하기 위한 핵심적인 도구였으며, 호환 가능한 스크립트 로더를 사용해야만 모듈형 자바스크립트를 구현할 수 있었다.

## 10.2 AMD
AMD(Asynchronous Module Definition) 모듈 형식은 모듈과 의존성 모두를 비동기적으로 로드할 수 있도록 설계된 모듈 정의 방식이다. 이러한 AMD 형식의 주요 목표는 개발자들이 활용할 수 있는 모듈형 자바스크립트 솔루션을 제공하는 것이다. 또한 AMD 형식은 본래 비동기적이면서도 높은 유연성을 가지고 있어, 개발 과정에서 흔히 발생하는 코드와 모듈 간 긴밀한 결합을 줄여주는 등의 장점을 가지고 있다.

### 10.2.1 모듈 알아보기
AMD에서 주목할만한 가장 중요한 두 가지 개념은 모듈 정의를 구현하는 define 메서드와 의존성 로딩을 처리하는 require 메서드로 나뉜다. define 메서드는 이름이 있는 모듈 혹은 익명 모듈을 정의하는데 사용된다. <br />
반면에, requir는 일반적으로 최상위 자바스크립트 파일이나 모듈 내에서 의존성을 동적으로 가져오고자 할 때 사용된다.
```javascript
define(["lib/Deferred"], function(Deferred) {
    var defer = new Deferred(); // Deferred 객체 생성

    require(["lib/templates/?index.html", "lib/data/?stats"], 
    function(template, data) {
        defer.resolve({ template: template, data: data }); // 비동기 작업 완료 시 resolve 호출
    });

    return defer.promise(); // Promise 반환
});
```
### 10.2.2 AMD 모듈과 jQuery
jQuery를 비동기 호환 모듈로 등록하기<br />
AMD를 사용하면서 jQuery의 버전이 전역 공간에 유출되는 것을 원치 않는다면, jQuery를 사용하는 최상위 모듈 내에서 noConflict를 호출해야 한다. 또한, 한 페이지에서 여러 버전의 jQuery를 사용하는 것이 가능하기 때문에, AMD 로더는 특별한 고려사항을 적용해야 한다. jQuery는 이러한 문제들을 인식하고 있는 로더, 즉 define.amd.jQuery를 포함하고 있는 로더에만 AMD 로더로 등록한다.<br />
<br />
어째서 AMD가 모듈형 자바스크립트 작성에 더 좋을까?
- 유연한 모듈 정의 방식에 대한 명확한 제안을 제공한다.
- 기존에 많이 사용되고 있는 전역 네임스페이스나 `<script>` 태그 방식에 비해 훨씬 더 구조화되어 있다. 독립적인 모듈과 의존성을 명확하게 선언할 수 있다.
- 모듈 정의가 독립적으로 이루어지기 때문에 전역 네임스페이스의 오염을 방지할 수 있다.
- 일부 대체 솔루션(예를 들어 CommonJS)에 비해 더 효과적이라는 주장이 있다. AMD는 다른 크로스 도메인, 로컬 환경, 디버깅 등에서 문제가 없으며, 서버 사이드 툴을 사용할 필요도 없다. 대부분의 AMD로더는 빌더 과정없이 브라우저에서 모듈을 로딩하는 것을 지원한다.
- 여러 모듈을 하나의 파일로 가져오기 위한 전송(transport) 방식을 제공한다. CommomJS와 같은 방식은 아직 전송 형식에 도입하지 못하고 있다.
- 스크립트의 지연로징(lazy-loading)을 지원한다.

### 10.2.3 AMD에 대한 결론
AMD는 탄탄한 애플리케이션을 작성할 수 있는 등 여러 장점을 제공한다는 결론에 도달했다. 전역 객체의 사용에 대한 걱정을 줄여주고, 변수에 모듈을 할당할 수 있게 해주고, 브라우저 환경의 모듈 작동을 위해 서버 사이드에서의 반환이 따로 필요하지 않으며, 의존성 관리 측면에서도 매우 효율적이다.<br />
물론 AMD도 완벽한 것은 아니다. AMD 를 한동안 사용해본 개발자는 AMD의 초기 설정 코드 작성이 다소 귀찮았을 것이다.

## 10.3 CommonJS
CommonJS는 서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안이다. AMD와 달리 I/O, 파일 시스템, 프로미스 등 더욱 광범위한 부분을 다룬다. <br />
CommonJS는 모듈과 패키지, 두 가지에 대한 표준을 정립하려 노력했다.

### 10.3.1 CommonJS 시작하기
구조적 관점에서 볼 때, CommonJS 모듈은 재사용 가능한 자바스크립트 코드로써 외부 의존 코드에 공개할 특정 객체를 내보낸다. AMD와 달리 CommonJS는 모듈을 함수로 감싸는 작업이 필요하지 않다(예를 들어 define을 사용하지 않는다).<br />
CommonJS 모듈은 두 가지 핵심 요소로 구성된다. exports 변수는 다른 모듈에 내보내고자 하는 객체를 담는다. require 함수는 다른 모듈에서 내보낸 객체는 가져올 때 사용하는 함수이다.

### 10.3.2 여러 의존성 동시에 사용하기
app.js 예시
```javascript
var modA = require("./foo");
var modB = require("./bar");

exports.app = function (){
    console.log("Im an application");
};

exports.foo = function (){
    return modA.hellowWorld();
};
```
<br />

bar.js 예시
```javascript
exports.name = "bar";
```
<br />

foo.js 예시
```javascript
require("./bar");
exports.helloWorld = function (){
    return "Hello World!";
};
```

### 10.3.3 Node.js 환경에서의 CommonJS
최근에는 ES 모듈 형식이 재사용 가능한 자바스크립트 코드를 모듈화하는 표준으로 자리잡았지만, 여전히 Node.js 환경에서는 CommonJS가 기본 형식으로 쓰인다. CommonJS 모듈은 Node.js에서 사용할 자바스크립트 코드를 패키징하기 위해서 처음 등장했다. 물론, Node.js 버전 13.2.0 이후의 안정적인 버전에서는 ES 모듈도 지원하기 시작했다.<br />
ES6 모듈 문법으로 작성된 라이브러리는 Node.js에서 실행할 경우 내부적으로 CommonJS로 트랜스파일 될 것이다.

### 10.3.4 CommonJS는 브라우저 환경에 적합할까?
CommonJS 반대파에서는, CommonJS의 많은 API가 서버 환경을 위한 기능들을 다루기 때문에 자바스크립트로는 브라우저 수준에서 구현할 수 없다고 주장하였다. 대표적인 예로, io, system, js와 같은 API들은 그 기능 특성상 구현이 불가능할 수 있다는 것이었다.<br />
ES2015와 AMD 모듈은 생성자나 함수 같은 것을 더 세밀하게 정의할 수 있다. 반면 CommonJS는 오직 객체만을 정의할 수 있기 때문에 생성자를 정의하려는 경우 번거로운 작업이 동반될 수 있다. 새로운 Node.js 프로젝트의 경우, ES2015 모듈은 서버에서 CommonJS의 대안으로 사용될 수 있으며, 클라이언트와 서버 사이의 사용 방법에 차이가 없다. 덕분에 브라우저와 서버 양쪽 환경에서 실행될 수 있는 동형(Isomorphic) 자바스크립트 코드의 구현이 쉬워졌다.

## 10.4 AMD vs CommonJS: 동상이몽
AMD와 CommonJS는 서로 다른 목표를 가진 유효한 모듈 형식이다.<br />
AMD는 브라우저 우선 접근 방식을 채택하여 비동기 동작과 간소화된 하위 호환성을 선택한 반면, 파일 I/O에 대한 개념은 없다. 또한 객체, 함수, 생성자, 문자열, JSON 등 다양한 형태의 모듈을 지원하며 브라우저에서 자체적으로 실행된다는 면에서 대단히 유연한 포맷이다.<br />
반면에 CommonJS는 서버 우선 접근 방식을 취하며 동기적 작동, 전역 변수와의 독립성 그리고 미래의 서버 환경을 고려한다. 이러한 특징이 의미하는 바는 CommonJS가 언래핑된 모듈을 지원하기 때문에 ES2015+ 표준에 조금 더 가깝게 느껴진다는 것이다. 이를 통해 AMD에서 필수적인 define() 함수를 사용하지 않아도 된다. 다만, CommonJS 모듈은 오직 객체만을 모듈로써 지원한다.

### 10.4.1 UMD: 플러그인을 위한 AMD 및 CommonJS 호환 모듈
브라우저와 서버 환경에서 모두 작동할 수 있는 모듈을 원하는 개발자에게는 기존 AMD와 CommonJS의 약점을 해결하는 방안이 필요했다. 그리고 UMD(Universal Module Definition) 형식을 만들었다.<br />
UMD는 실험 단계의 모듈 포맷이다. 개발 당시에 존재했던 주요 스크립트 로딩 기술의 대부분을 활용하여 클라이언트 및 서버 환경 모두에서 작동하는 모듈을 구현했다.<br />
UMD는 AMD와 CommonJS 모두에서 동작할 수 있는 다양한 패턴을 제공하고자 했다. 이를 통해 다양한 환경에서 사용할 수 있는 모듈을 개발할 때 겪는 일반적인 호환성 문제를 해결할 수 있을 것이다.
<br />
CommonJS, AMD 또는 브라우저 전역 객체를 활용하여 모듈 생성하기
```javascript
(function (root, factory) {
    if(typeof experts === "object"){
        // CommonJS 방식인 경우
        factory(exports, require("b"));
    } else if(typeof define === "function" && define.amd){
        // AMD 방식인 경우. 익명 모듈로 등록한다.
        define(["exports", "b"], factory);
    } else {
        // 브라우저 전역 변수 사용의 경우
        factory((root.commonJsStrict = {}), root.b);
    }
})(this, function (exports, b){
    // "b" 모듈에 정의된 항목들을 사용할 수 있다.

    // exports 객체에 추가된 프로퍼티나 메서드가 이 모듈에서 제공된다.
    exports.action = function (){};
}));
```

## 10.5 마치며
이번 장에서는 ES2015 이전에 사용된 다양한 모듈 형식을 활용한 모듈형 자바스크립트 작성 방법을 살펴보았다. <br />
이러한 모듈 형식들은 단순히 모듈 패턴만 사용하는 것과 비교하여 여러 장점이 있다. 대표적으로, 전역 변수 관리의 필요성 감소, 정적/동적 의존성 관리에 대한 향상된 지원, 스크립트 로더와의 높은 호환성, 서버 환경에서의 모듈 호환성 강화 등이 있다.
