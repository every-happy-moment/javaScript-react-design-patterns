# 11_네임스페이스 패턴
네임스페이스(Namespace)는 코드 단위를 고유한 식별자로 그룹화한 것을 뜻한다. <br /> 자바스크립트는 다른 언어들처럼 네임스페이스를 기본적으로 지원하지는 않지만, 객체와 클로저를 활용하여 비슷한 효과를 얻을 수 있다.

## 11.1 네임스페이스의 기초
네임스페이스 패턴의 종류
- 단일 전역 변수
- 접두사 네임스페이스
- 객체 리터럴 표기법
- 중첩 네임스페이스
- 즉시 실행 함수 표현식
- 네임스페이스 주입

## 11.2 단일 전역 변수 패턴
하나의 전역 변수를 주요 참조 객체로 사용하는 방식. 문제는 다른 개발자가 같은 이름의 전역 변수를 이미 사용하고 있을 가능성이 있다는 것이다. 만약 그렇다면 충돌이 발생할 수 있다.

## 11.3 접두사 네임스페이스 패턴
단일 전역 변수 문제에 대한 해결책 중 하나는 접두사 네임스페이스(Prefix Namespace) 패턴을 활용하는 것이다. 기본 개념은 고유한 접두사(예: myApplication)를 선정한 다음에 모든 메서드, 변수, 객체를 이 접두사 뒤에 붙여서 정의하면 된다.<br />
이 패턴의 문제점은 애플리케이션이 커짐에 따라 많은 전역 객체가 생성된다는 점이다. 또한 다른 개발자가 같은 접두사를 전역 네임스페이스에서 사용하지 않고 있었을 것이라고 가정하고 있기에 이 패턴을 선택할 때는 주의해야 한다.

## 11.4 객체 리터럴 표기법 패턴
객체 리터럴 표기법(Object Literal Notation)은 일종의 객체로, 키와 값으로 이뤄진 집합을 가지며, 각각의 키와 값은 콜론(:)으로 구분된다. 또한 키 자체가 새로운 네임스페이스가 될 수 있다.
```javascript
const myApplication = {
    getInfo(){
        //...
    },

    // 또한 객체 안에 추가로 객체 네임스페이스를 만들어 필요한 요소들을 담을 수도 있다.
    models: {},
    view: {
        pages: {}
    },
    collections: {},
};

// 네임스페이스에 속성을 직접 추가하는 방법도 있다.
myApplication.foo = () => "bar";

myApplication.utils = {
    toString(){
        //...
    },
    export(){
        //...
    },
};
```
객체 리터럴 표기법 패턴은 전역 네임스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성하는데 도움을 준다. 특히 쉽게 읽을 수 있고, 깊은 중첩까지 지원하는 구조를 구현할 때 매우 유용하다. 또한, 객체 리터럴 표기법 패턴은 일반적인 전역 변수들과 달리 동일한 이름의 변수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성을 크게 줄여준다.

## 11.5 중첩 네임스페이스 패턴
객체 리터럴 패턴을 발전시킨 형태가 바로 중첩 네임스페이스(Nested Namespace) 패턴이다. 중첩 네임스페이스 패턴은 다른 패턴에 비해 충돌 위험이 낮은 편이다. 비록 같은 이름의 네임스페이스가 존재한다고 하더라도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성은 낮기 때문이다.<br />
단일 객체 네임스페이스 패턴과 중첩 네임스페이스 패턴의 성능 차이는 크지 않다(장점).

## 11.6 즉시 실행 함수 표현식 패턴
자바스크립트에서 즉시 실행 함수로 정의된 내부의 변수와 함수 모두 외부에서 접근할 수 없다. 따라서, 함수를 호출하는 것만으로도 쉽게 코드의 은닉성을 구현할 수 있다.<br />
즉시 실행 함수는 애플리케이션의 로직을 캡슐화하여 전역 네임스페이스로부터 보호하는데 널리 사용되는 방법이다. 하지만 이러한 특징은 네임스페이스의 영역에서도 유용하게 사용될 수 있다.
```javascript
const namespace = namespace || {};

// 함수 매개변수로 네임스페이스 객체를 전달하고, 공용 메서드와 속성을 할당한다.
((o) => {
    o.foo = "foo";
    o.bar = () => "bar";
})(namespace);

console.log(namespace);
```

## 11.7 네임스페이스 주입 패턴
네임스페이스 주입(Namespace injection)패턴은 즉시 실행 함수 패턴의 또다른 변형이다. 이 패턴에서는 함수내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에 메서드와 속성을 '주입'한다.<br />
네임스페이스 주입 패턴의 장점은 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용할 수 있다는 점이다. 또한 이후에 확장될 기본 메서드(예: 게터와 세터)에 적용할 때 유용하다. 단점은, 같은 목적을 달성하는 더 쉽고 효율적인 방법(예: 심층객체 확장 또는 병합)이 존재할 수 있다는 것이다.

## 11.8 고급 네임스페이스 패턴
### 11.8.1 중첩 네임스페이스 자동화 패턴
기존의 전역 변수 하위에 중첩된 네임스페이스를 자동으로 정의하는 방법이다. 하나의 문자열 인자를 받아서 파싱한 뒤에 필요한 객체를 기반 네임스페이스에 자동으로 추가하는 간편한 방법.
```javascript
// 최상위 네임스페이스에 객체 리터럴을 할당한다.
const myApp = {};

// 문자열 형식의 네임스페이스를 파싱하고 자동으로 중첩 네임스페이스를 생성해주는 간편한 함수
function extend(ns, ns_string){
    const parts = ns_string.split('.');
    let parent = ns;
    let pl;

    pl = parts.length;

    for(let i = 0; i < pl; i++){
        // 프로퍼티가 존재하지 않을 경우에만 생성한다.
        if(typeof parent[parts[i]] === "undefined"){
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
}

// 사용법
// myApp에 깊게 중첩된 네임스페이스를 확장한다.
const mod = extend(myApp, "modules.module2"); 
```

### 11.8.2 의존성 선언 패턴
중첩 네임스페이스 패턴을 약간 변형한 형태인 의존성 선언(Dependency Declaration) 패턴<br />
로컬 변수를 사용하는 것이 전역 변수(예: myApp)를 매번 사용하는 것보다 더 빠르다. 또한 후속 작업에서 중첩된 속성이나 하위 네임스페이스에 매번 접근하는 것보다 더 편리하고 성능이 뛰어나다. 특히 복잡한 애플리케이션에서는 가독성을 높일 수 있다.<br />
스토얀은 함수나 모듈에서 사용할 로컬 네임스페이스를 함수 영역의 상단에 선언할 것을 권장하며(단일 변수 패턴 사용), 이 방식을 의존성 선언 패턴이라고 부른다.


### 11.8.3 심층 객체 확장 패턴
자동 스페이스 생성에 대한 또 다른 해결책은 심층 객체 확장(Deep Object Extenstion) 패턴이다. 객체 리터럴 표기법으로 선언된 네임스페이스는 다른 객체(또는 네임스페이스)와 쉽게 확장(또는 병합)될 수 있다. 병합 이후에는 두 네임스페이스의 속성과 함수 모두를 동일한 네임스페이스에서 접근할 수 있다.
```javascript
// 객체 할당 및 재귀 호출을 사용한 심층 객체 확장
function extendObjects(destinationObject, sourceObject){
    for(const property in sourceObject){
        if(
            sourceObject[property] && !Array.isArray(sourceObject[property])
        ){
            destinationObject[property] = destinationObject[property] || {};
            extendObjects(destinationObject[property], sourceObject[property]);
        }else{
            destinationObject[property] = sourceObject[property];
        }
    }
    return destinationObject;
}

// 사용 예시
const myNamespace = myNamespace || {};

extendObject(myNamespace, {
    utils: {}
});

console.log("test 1", myNamespace);
```

## 11.9 권장하는 패턴
대부분의 대규모 애플리케이션에 추천하는 방법은 객체 리터럴 패턴을 사용한 중첩 네임스페이스 방법이다. 그리고 가능하다면 중첩 네임스페이스 자동화 패턴을 구현해서 적용하면 좋다.