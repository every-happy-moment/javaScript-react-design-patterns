# 8.1 MVC 패턴

- 어플리케이션의 구조를 개선하기 위해 관심사 분리를 활용하는아키텍처 디자인 패턴
- 비즈니스 데이터(모델), UI(뷰)를 분리하고 컨트롤러가 로직과 사용자 입력을 관리하는 구조
- 모델(Model)L 도메인 관련 데이터를 표현했으며 UI에 대해서는 관여하지 않음.
- 뷰(View): 모델의 현재 상태를 표현. 관찰자 패턴을 사용해 모델이 변경, 수정될 때마다 뷰가 알아차릴 수있도록 함.
- 컨트롤러(Controller): 사용자의 상호작용을 처리하고 뷰에 무엇을 보여줄지 사용자의 입력을 어떻게 처리할지 등을 결정

# 8.2 Javascript 의 MVC
- js개발자는 MVC패턴과 그 변형 버전들이 제공하는 장점을 이해해야한다.
    - 유지관리하기 힘든 코드(일명 스파게티코드)를 피하는 것이 중요.


### 8.2.1 모델
- 어플리케이션의 데이터를 관리하는 역할
- 모델이 변경될 때, 관찰자에게 변경사항을 알린다.
- ex) 사진 갤러리 어플
    - 사진: 고유한 도메인 관련 데이터를 보여줌 -> 모델
    - 설명, 이미지 소스, 추가 메타데이터와 같은 속성 포함
    - 특정 사진은 인스턴스로 저장되어 재사용 가능
- 모델 데이터는 지속적으로 유지 되어야함.
    - 최근 상태가 메모리나 로컬 저장소, 데이터베이스와도 동기화될 것을 전제로 모델을 수정 가능
- MVC/MV* 프레임워크에서는 모델을 컬렉션으로 그룹화하는 기능을 제공한다.

### 8.2.2 뷰

- 시각적인 표현하고, 현재 상태의 특정 부분을 보여준다
- 일반적으로 뷰는 모델을 관찰하고 모델의 변화가 생기면 알림을 받는다. -> 이를 통해 뷰는 스스로 업데이트가 가능하다.
- ex) 사진 갤러리 어플
    - 특정사진을 선택한 사용자가 해당 사진의 메타데이터를 편집할 수 있는 “편집뷰”를 제공하여 모델 편집을 가능하게 한다.

### 8.2.3 템플릿
- 문자열의 연결(concat)을 통해 큰 마크업 블록을 수동으로 생성하는 것은 성능 이슈를 유발한다. -> document.write (x) 
- ES6부터 태그된 템플릿 리터럴 내의 변수는 ${variable} 구문을 추가하여 쉽게 추가가 가능하다.
- 템플릿 자체는 뷰가 아니다.
- 프레임워크가 템플릿 명세에 따라 뷰를 생성할 수 있도록 뷰 객체의 일부 또는 전체를 지정하는 방법이 될 수 있다.

### 8.2.4 컨트롤러
- 기능을 더 간단한 모듈로 나눌 수 있도록 해준다
    - 전반적인 유지보수의 단순화: 업데이트 해야할 때, 변경사항이 데이터 중심인지 단순한 시각적인 변경인지 정확하게 구분이 가능하다.
    - 모델과 뷰의 분리: 단위테스트 작성이 간편해진다.
    - 하위수준의 모델 및 컨트롤러 코드 중복이 제거된다.
    - 모듈화를 통해 코어 로직을 담당하는 개발자와 UI 작업을 담당하는 개발자가 동시에 작업이 가능해진다.

# 8.6 MVP 패턴
프레젠테이션 로직의 개선에 초점을 맞춘 MVC디자인 패턴의 파생 버전이다.


### 8.6.1 모델 뷰 프레젠터
- 뷰에서의 이벤트 호출은 presenter로 위임한다.
- presenter와 view는 분리되어야 하며, 인터페이스를 통해 뷰와 통신한다.
    - 단위테스트를 모킹할 수 있는 등 많은 장점을 제공한다.
- presenter는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트한다.
- presenter는 모델과 view를 효과적으로 연결하는데 이는 원래 MVC에서 컨트롤러가 담당하는 부분이다.
- 이벤트를 구독하여 뷰를 업데이트할 수 있도록 하는 것이 presenter의 역할이다.
- 데이터 바인딩이 지원되지않기 떄문에 별도의 작업이 필요하다.


### 8.6.2 MVP vs MVC
- MVP는 일반적으로 presenter 로직을 최대한 재사용해야하는 애플리케이션에서 사용
- 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합하지 않을 수 있다.
- 	MVC에서는 컨트롤러에 의존해야할 수 있기 때문이다.


# 8.7 MVVM
MVC와 MVP를 기반으로 하는 아키텍처 패턴으로 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리한다.
동일한 코드 베이스 내에서 UI 작업과 개발 작업을 거의 동시에 진행할 수 있다.


### 8.7.2 모델
어플리케이션이 사용할 도메인 관련 데이터나 정보를 제공한다. 모델은 정보를 담고 있지 동작을 다루지 않는다. 또다른 계층인 뷰모델에서 캡슐화하여 처리해야하는 비즈니스 로직으로 간주된다.

모델의 역할 중 유일한 예외는 데이터 유효성 검사이다. 기존 모델을 정의하거나 업데이트 하는데 사용되는 데이터에 대한 유효성 검사는 모델에서  수행되도록 허용한다.


### 8.7.3 뷰
뷰모델의 상태를 표현한 상호작용이 가능한 UI이다. 뷰는 수동적이라기 보다는 능동적으로 볼 수 있으며, MVC와 MVP의 뷰도 마찬가지이다.

수동적 뷰는 단순히 화면을 출력할 뿐 사용자의 입력을 받아들이지 않는다. 반면, MVVM의 능동적 뷰는 데이터바인딩, 이벤트, 동작들을 포함하구 있어 뷰모델에 대한 이해가 필요하다. 뷰모델로부터 발생한 이벤트를 처리하는 책임은 여전히 뷰가 갖고 있다.

### 8.7.4 뷰모델
데이터 변환기의 역할을 하는 특수한 컨트롤러이다. 모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고 뷰에서 발생한 명령(사용자 조작이나 이벤트)을 모델로 전달한다.

뷰에는 포맷된 날짜가 표시되고, 뷰모델은 뷰와 모델 둘 사이를 잇는 다리 역할을 수행한다.
이러한 관점에서 뷰모델은 뷰보단 모델에 더 가깝다고 볼 수 있다. 뷰모델은 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트 하며, 뷰에 이벤트를 발생시키는 등의 기능을 수행하기 위한 메서드도 제공할 수 있다.

### 8.7.5 뷰와 뷰모델 복습
뷰와 뷰모델은 데이터 바인딩과 이벤트를 통해 소통한다. 뷰모델은 모델의 속성을 단순히 제공하는 것 뿐만 아니라, 데이터 유효성검사 같은 메서드와 기능에 대한 접근도 허용된다.

뷰는 자체 UI이벤트를 처리하고, 필요에 따라 뷰모델에 연결한다. 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트 된다.

# 장단점

### 8.8 1 장점
- MVVM은 UI와 이를 구동하게 해주는 요소를 동시에 개발할 수 있도록 한다.
- MVVM은 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직의 양을 줄여준다.
- 뷰모델은 이벤트 중심 코드에 비해 단위테스트가 더 쉽다.
- 뷰모델은 UI 자동화나 상호작용에 대한 고려 없이도 테스트가 가능하다

### 8.8.2 단점
- 단순한 UI의 경우 MVVM은 과도한 구현이 될 수 있다.
- 데이터 바인딩은 선언적이고, 사용하기 편리할 수 있지만, 단순히 중단점을 설정하는 명령형 코드에 비해 디버깅이 더 어려울 수 있다.
- 복잡한 어플리케이션에서는 데이터 바인딩이 상당한 관리 부담을 만들어 낼 수 있다.
- 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 더 어려울 수 있다.

# 8.10 최신 MV* 패턴
기술적으로 React나 Vue.js는 애플리케이션의 뷰 또는 프레젠테이션 계층을 구성한다. vue는 공식적으로 뷰모델을 사용하는 MVVM 패턴이라고 주장한다. React는 MV*패턴에 대한 몇 가지 추가적인 사항이 고려된다.

### 8.10.1 MV* 패턴과 React
React는 MVC 프레임워크가 아니다. UI구축을 위한 Javascript 라이브러리 이며, 주로 SPA 개발에 사용된다.
전통적으로 백엔드에서 구현되고 사용되는 MVC 패턴과 잘 맞지 않기 때문에 MVC로 분류되지않는다. View 계층을 원하는대로 구성하게 해주는 렌더링 라이브러리이다.

선언형 프로그래밍 방식을 따른다. 개발자는 원하는 상태를 기술하고, React는 그 상태를 기반으로 적절한뷰를 렌더링한다. MVC 디자인 패턴에서 사용하지 않는 이유는 서버가 브라우저에 뷰를 직접 제공하지 않고 데이터를 제공하기 떄문이다. 브라우저에서 구문분석하여 실제 뷰를생성한다.

단순히 비유를 하자면,
모델: 비동기 데이터
뷰: 컴포넌트
컨트롤러: hook





