# 07_자바스크립트 디자인 패턴

## 7.1 생성 패턴
생성 패턴은 객체를 생성하는 방법을 다룬다.
- 생성자 패턴
- 모듈 패턴
- 노출 모듈 패턴
- 싱글톤 패턴
- 프로토타입 패턴
- 팩토리 패턴

## 7.2 생성자 패턴
생성자(Constructor)는 객체가 새로 만들어진 뒤 초기화하는데 사용되는 특별한 메서드이다. E2015 버전 이후로 생성자를 가진 클래스를 만들 수 있게 되었다.

### 7.2.1 객체 생성
자바스크립트에서 새로운 객체를 만들 때 사용하는 세 가지 일반적인 방법
1. 리터럴 표기법을 사용하여 빈 객체 생성 <br />
const newObject = {};
2. Object.create() 메서드를 사용하여 빈 객체 생성 <br />
const newObject = Object.create(Object.prototype);
3. new 키워드를 사용하여 빈 객체 생성 <br />
const newObject = new Object(); <br />

객체에 키와 값을 할당하는 방법
1. 도트 Dot(.) 문법
2. 대괄호 문법
3. Object.defineProperty
4. Object.defineProperties

### 7.2.2 생성자의 기본 특징
E2015에 도입된 자바스크립트의 클래스는 객체 템플릿을 정의하고 캡슐화 및 상속을 구현할 수 있게 했다. <br />
클래스는 새 객체를 초기화하는 Constructor()라는 이름의 메서드를 가지고 있어야 한다. 또한 new 키워드는 생성자를 호출할 수 있으며, 생성자 내부에서 사용된 this 키워드는 새로 생성된 해당 객체를 가리킨다.

### 7.2.3 프로토타입을 가진 생성자
자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있게 한다. 생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다.

## 7.3 모듈 패턴
모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는데 효과적으로 활용된다.

### 7.3.1 객체 리터럴
객체 리터럴 표기법은 객체는 중괄호({}) 안에서 키key 와 값value을 쉼표(,)로 구분하여 객체를 정의하는 방법이다. 객체 내부의 키는 문자열 또는 식별자를 사용하며 콜론(:)으로 끝마친다. 그리고 오류 방지를 위해 마지막 줄 끝에는 쉼표 사용을 권장하지 않는다. <br />
객체 리터럴은 속성으로 값과 메서드를 모두 가질 수 있다. 예를 들어 객체 안에 객체를 다시 생성할 수도 있다. <br />
객체 리터럴을 사용하면 코드를 캡슐화하여 깔끔하고 체계적으로 정리할 수 있다.

### 7.3.2 모듈 패턴
모듈 패턴은 전통적인 소프트웨어 엔지니어링 분야에서 클래스의 캡슐화를 위해 처음 고안되었다. 개발자들은 자바스크립트 모듈을 사용하여 객체, 함수, 클래스, 변수 등을 구성하여 다른 파일에 쉽게 내보내거나 가져올 수 있다. 이를 통해 서로 다른 모듈 간의 클래스 또는 함수명 충돌을 방지할 수 있다.

- 비공개 <br />
모듈 패턴은 클로저(closure)를 활용해 '비공개' 상태와 구성을 캡슐화한다. 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프(global scope)로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다. 모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수 있다.

### 7.3.3 모듈 패턴의 변형
- 믹스인(Mixin)가져오기 변형 <br />
이 변형된 패턴은 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달할 수 있게 한다. 이를 통해 전역 스코프 요소를 가져와 맘대로 이름을 지정(alias)할 수 있다.
- 내보내기 변형 <br />
이 변형은 따로 이름을 지정해주지 않고 전역 스코프로 변수를 내보낸다. <br />
export default module;<br />

장점<br />
- 모듈 패턴은 캡슐화 개념보다 객체 지향 프로그래밍 지식을 가진 초보 개발자가 이해하기 쉽다.
- 비공개를 지원한다. 모듈 패턴에서는 export를 이용해 바깥으로 노출한 값들만 접근할 수 있다. 바깥으로 노출하지 않은 값은 모듈 내부에 비공개로 유지된다. 따라서 불필요한 전역 스코프 오염을 방지할 수 있다.
- 모듈 패턴은 공개되면 안되는 코드를 캡슐화할 수 있다. 덕분에 여러 의존성을 동시에 사용할 수 있고 이름의 충돌도 피할 수 있다. <br />

단점<br />
- 공개와 비공개 멤버를 서로 다르게 접근해야 한다는 점. 공개 여부를 바꾸고 싶다면 값이 위치한 파일로 가서 각각 바꾸어주어야만 한다.
- 자동화 단위 테스트(unit test)에서 비공개 멤버는 제외된다는 것과 핫 픽스(hot fix)가 필요한 오류를 고칠 때 복잡도를 높인다는 점

### 7.3.4 WeakMap을 사용하는 최신 모듈 패턴
ES6에서 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체이다. WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵으로 참조되지 않는 키는 가비지 컬렉션(GC)의 대상이 된다는 뜻이다.

## 7.4 노출 모듈 패턴
모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴. export 와 import를 통해 공개 여부를 결정한다.

### 7.4.1 장점
노출 모듈 패턴을 사용하면 코드의 일관성이 유지된다. 또한 모듈의 가장 아래에 위치한 공개 객체를 더 알아보기 쉽게 바꾸어 가독성을 향상시킨다.

### 7.4.2 단점
비공개 함수를 참조하는 공개 함수를 수정할 수 없다. 이는 비공개 함수가 비공개 구현을 참조하기 때문에 발생하며, 수정을 해도 함수가 변경될 뿐 구현이 변경되는 것은 아니기 때문이다.<br />
비공개 변수를 참조하는 공개 객체 멤버 또한 수정이 불가능하다. 따라서 노출 모듈 패턴으로 만들어진 모듈은 기존 모듈보다도 취약할 수 있으므로 사용시 주의해야 한다.

## 7.5 싱글톤 패턴
싱클톤(singleton) 패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다. 이 패턴은 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.<br />
다만 자바스크립트에서 싱글톤이 필요하다는 것은 설계를 다시 생각해봐야 한다는 신호일 수 있다. 자바스크립트는 객체를 직접적으로 생성할 수 있기 때문에 싱글톤 클래스를 만드는 대신 직접 객체 하나를 생성할 수도 있기 때문이다. <br />

단점 <br />
- 싱글톤임을 파악하는 것이 힘들다
- 테스트하기 힘들다
- 신중한 조정이 필요하다

### 7.5.1 리액트의 상태 관리
리액트에서는 싱글톤 대신 Context API나 리덕스(Redux)같은 전역 상태 관리 도구를 이용하여 개발할 수 있다. 싱글톤과는 달리, 이러한 전역 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다. 컴포넌트가 전역 상태를 직접 변경할 수 없게 만들어 전역 상태가 의도한 대로 변경될 수 있도록 도와준다.

## 7.6 프로토타입 패턴
프로토타입 패턴은 프로토타입의 상속을 기반으로 한다. 이 패턴에서는 프로토타입 역할을 할 전용 객체를 생성하게 된다. 이렇게 만들어진 prototype 객체는 생성자를 통해 만들어진 객체의 설계도가 된다. <br />
프로토타입 패턴의 장점은 다른 언어의 기능을 따라하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것이다. 다른 디자인 패턴과 구별되는 특징이다.<br />
또한 방법이 쉬울 뿐 아니라 성능에서의 이점도 있다. 객체 내에 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있기 때문이다.

## 7.7 팩토리 패턴
팩토리(Factory) 패턴은 객체를 생성하는 생성 패턴의 하나이다. 다른 패턴과 달리 생성자를 필요로하지 않지만, 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다. 팩토리 패턴은 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성과정이 복잡할 때 특히 유용하다.

### 7.7.1 팩토리 패턴을 사용하면 좋은 상황
- 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕 타이핑(duck typing)같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때. 또한 디커플링(decoupling)에도 유용하다.

### 7.7.2 팩토리 패턴을 사용하면 안되는 상황
잘못된 상황에 팩토리 패턴을 적용하면 애플리케이션 복잡도가 크게 증가할 수 있다. 팩토리 패턴은 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가시킬 수 있다. 

### 7.7.3 추상 팩토리 패턴
추상 팩토리(Abstract Factory) 패턴은 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴이다. 또한 객체가 어떻게 생성되는지에 대한 세부사항을 알 필요 없이 객체를 사용할 수 있게 한다.<br />
객체의 생성 과정에 영향을 받지 않아야 하거나 여러 타입의 객체로 작업해야 하는 경우에 추상 팩토리를 사용하면 좋다.

## 7.8 구조 패턴
구조(Structural) 패턴은 클래스와 객체의 구성을 다룬다. 클래스와 객체를 체계적으로 구성하는 최고의 방법과 사례를 제공한다.
- 퍼사드 패턴
- 믹스인 패턴
- 데코레이터 패턴
- 플라이웨이트 패턴

## 7.9 퍼사드 패턴
퍼사드(Facade)란 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것을 뜻한다. 퍼사드 패턴은 심층적인 복잡성을 숨기고, 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴이다. jQuery 같은 자바스크립트 라이브러리에서 흔히 볼 수 있는 구조 패턴이다. <br />
퍼사드 패턴은 클래스의 인터페이스를 단순화하고 코드의 구현 부분과 사용 부분을 분리한다. 이를 통해 하위 시스템에 직접 접근하기보단 간접적으로 상호작용하여 에러를 줄일 수도 있다. 퍼사드의 장점은 사용하기 쉽다는 점과 패턴구현에 필요한 코드의 양이 적다는 점이다.<br />
퍼사드 패턴을 단독으로 사용해야만 하는 것은 아니다. 모듈 패턴과 같은 다른 패턴과도 어울릴 수 있다.

## 7.10 믹스인 패턴
C++ 이나 Lisp 같은 전통적인 프로그래밍 언어에서 믹스인은 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스이다.

## 7.11 서브클래싱
부모 클래스를 확장하는 자식 클래스를 서브클래스라고 한다. 서브클래싱이란 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것을 뜻한다. 서브클래스는 부모 클래스에서 먼저 정의된 메서드를 오버라이드(override)하는 것도 가능하다. 서브클래스의 메서드는 오버라이드된 부모 클래스의 메서드를 호출할 수도 있는데, 이를 메서드 체이닝(method chaining)이라고 부른다. 마찬가지로 부모 클래스의 생성자를 호출할 수도 있는데, 이를 생성자 체이닝(consturctor chaining)이라고 부른다.

## 7.12 믹스인
자바스크립트에서는 기능의 확장을 위해 믹스인의 상속을 이용한다. 믹스인은 최소한의 복잡성으로 객체의 기능을 빌리거나 상속할 수 있게 해준다. 게다가 믹스인은 다른 여러 클래스를 아울러 쉽게 공유할 수 있는 속성과 메서드를 가진 클래스이다.

### 7.12.1 장점과 단점
믹스인은 함수의 중복을 줄이고 재사용성을 높인다. 애플리케이션에서 객체 인스턴스 사이에 공유되는 기능이 있다면 믹스인을 통해 기능을 공유하여 중복을 피하고 고유 기능을 구현하는데에 집중할 수 있다. <br />
하지만 몇몇의 개발자들은 클래스나 객체의 프로토타입에 기능을 주입하는 것을 나쁜 방법이라고 여긴다. 프로토타입 오염과 함수의 출처에 대한 불확실성을 초래하기 때문이다. 어떠면 실제 대규모 시스템에서는 그럴지도 모른다. 

### 7.13 데코레이터 패턴
데코레이터(Decorator) 패턴은 코드 재사용을 목표로 하는 구조 패턴이다. 믹스인과 마찬가지로 객체 서브클래싱의 다른 방법이라고 생각하면 된다.<br />
기본적으로 데코레이터는 기존 클래스에 동적으로 기능을 추가하기 위해 사용한다. 데코레이터를 사용하면 기존 시스템의 내부 코드를 힘겹게 바꾸지 않고도 기능을 추가할 수 있게 된다. 데코레이터를 사용하는 주된 이유는 애플리케이션의 기능이 다양한 타입의 객체를 필요로 할 수도 있기 때문이다. <br />
데코레이터 패턴은 객체의 생성을 신경쓰지 않는 대신 기능의 확장에 좀 더 초점을 둔다. 프로토타입 상속에 의지하기 보다는 하나의 베이스 클래스에 추가 기능을 제공하는 데코레이터 객체를 점진적으로 추가한다. 이는 서브클래싱 대신 베이스 객체에 속성이나 메서드를 추가하여 간소화하겠다는 아이디어이다.

## 7.14 의사 클래스 데코레이터
### 7.14.1 인터페이스
인터페이스는 스스로 문서의 역할을 하고 재사용성을 높인다. 이론적으로 인터페이스의 변경사항이 객체의 구현에도 전달되게 하면서 코드의 안정성을 높인다. <br />
다만 인터페이스는 자바스크립트에 내장된 기능이 아니므로 필요하다면 인터페이스가 내장된 타입스크립트를 사용하면 된다.

### 7.14.2 추상 데코레이터
추상 데코레이터는 모든 가능한 조합의 클래스를 따로 정의하지 않고도, 필요한 만큼의 데코레이터만을 사용하여 베이스 클래스에 독립적으로 기능을 추가할 수 있게 해준다. 데코레이터를 객체를 동적으로 확장할 수 있으므로 이미 동작하는 시스템의 내용을 변경하기에 매우 적합한 패턴이다.

## 7.15 장점과 단점
데코레이터 패턴의 객체는 새로운 기능으로 감싸져 확장되거나 '데코레이트'될 수 있으며 베이스 객체가 변경될 걱정 없이 사용할 수 있다. 더 넓은 의미에서 봤을 때 수많은 서브클래스에 의존할 필요도 없다. <br />
그러나 주의할 점은 네임 스페이스에 작고 비슷한 객체를 추가하기 때문에 잘 관리하지 않는다면 애플리케이션의 구조를 무척 복잡하게 만들 수도 있다. 또한 이 패턴에 익숙하지 않은 다른 개발자가 패턴의 사용 목적을 파악하기 어렵게 되어 관리가 힘들어질 수 있다. <br />
이러한 단점은 충분한 문서화나 패턴에 대한 이해도를 높임으로써 해결할 수 있다.

## 7.16 플라이웨이트 패턴
플라이웨이트(Flyweight)패턴은 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결 방법이다. 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하는 목적을 가지고 있다. 복싱의 체급에서 이름을 따왔으며 플라이급(플라이웨이트)이라는 이름은 이 패턴의 목표가 메모리 공간의 경량화이기 때문이다.

### 7.16.1 사용법
1. 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유하는 방법
2. DOM 레이어에 적용하는 방법

### 7.16.2 데이터 공유
플라이웨이트 패턴에는 두 가지 개념이 있다. 내재적(intrinsic) 상태와 외재적(extrinsic) 상태이다. <br />
내재적 정보는 객체의 내부 메서드에 필요한 것이며, 없으면 절대로 동작하지 않는다. 반면에 외재적 정보는 제거되어 외부에 저장될 수 있다. <br />
같은 내재적 정보를 지닌 객체를 팩토리 메서드를 사용해 만들어진 하나의 공유된 객체로 대체할 수 있다. 이를 통해 저장된 내부 데이터의 양을 상당히 줄일 수 있다. 외재적 정보를 다룰 때에는 따로 관리자를 사용한다. 

### 7.16.3 전통적인 플라이웨이트 구현 방법
플라이웨이트의 특징 세 가지
- 플라이웨이트 <br />
외부의 상태를 받아 작동할 수 있게 하는 인터페이스
- 구체적(Concrete) 플라이웨이트 <br />
플라이웨이트 인터페이스를 실제로 구현하고 내부 상태를 저장한다. 또한 다양한 컨텍스트 사이에서 공유될 수 있어야 하며 외부 상태를 조작할 수 있어야 한다.
- 플라웨이트 팩토리 <br />
플라이웨이트 객체를 생성하고 관리한다. 플라이웨이트를 공유할 수 있도록 보장하며 개별 인스턴스가 필요할 때 재사용할 수 있도록 관리한다. 

### 7.16.7 플라이웨이트 패턴과 DOM 객체
DOM은 하향식 topdown(이벤트 캡쳐링 event capturing)과 상향식 bottom-up(이벤트 버블링 event bubbling) 두 가지 방식의 이벤트 감지를 지원한다. <br />
플라이웨이트는 이벤트 버블링 과정을 추가 조정하는 데에 사용할 수 있다. <br />
이를 통해 개별적으로 관리되었던 많은 동작을 공유된 하나의 동작으로 바꾸어 메모리를 절약할 수 있게 해준다.

## 7.17 행위 패턴
행위(Behavior) 패턴은 객체 간의 의사소통을 돕는 패턴이다. 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 한다.
- 관찰자 패턴
- 중재자 패턴
- 커맨드 패턴

## 7.18 관찰자 패턴
관찰자(Observer) 패턴은 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴이다. 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다. 한 객체(주체 subject)를 관찰하는 여러 객체들(관찰자 observer)이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알림을 보낸다. 최신 프레임워크에서는 상태의 변화를 컴포넌트에 알리기 위해 관찰자 패턴을 사용하곤 한다. <br />
주체가 관찰자에게 중요한 변경사항을 알려야 할 때, 변경에 대한 알림과 함께 관련 정보를 모든 관찰자에게 전달한다. 관찰자가 더 이상 주체의 변경에 대한 알림을 받고 싶지 않을 경우, 관찰자 목록에서 제거하면 된다.

## 7.18.1 관찰자 패턴과 발행/구독 패턴의 차이점
실제 자바스크립트 환경에서는 발행/구독(Publish/Subscribe) 패턴이라는 변형된 형태의 구현이 더 널리 사용된다. <br />
관찰자 패턴에서는 이벤트 발생에 대해 알림 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되어야 한다. 반면, 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널을 둔다. 발행/구독 패턴의 핵심은 발행자와 구독자를 각자 독립적으로 유지한다는 것이다. <br />
이러한 점에서 관찰자 패턴과 구별되는데, 발행/구독 패턴에서는 적절한 이벤트 해들러를 가지고 있는 구독자라면 누구나 발행자가 전파하는 토픽의 알림을 받게 할 수 있다.<br />
발행/구독 패턴의 핵심은 시스템의 구성 요소 간에 느슨한 결합을 도모한다는 것이다. 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 된다.

### 7.18.2 장점
관찰자 패턴 또는 발행/구독 패턴을 사용하면 주체와 객체 사이에 동적인 관계가 형성된다. 이를 통해 애플리케이션의 여러 부분이 강하게 결합되어이 있을 때 구현하기 까다로운 뛰어난 유연성을 쉽게 구현할 수 있다. 이 패턴들은 시스템의 구성 요소 간 결합도를 낮추는 훌륭한 도구이다. 

### 7.18.3 단점
발행자/구독 패턴에서는 발행자와 구독자의 연결을 분리함으로써, 애플리케이션의 특정 부분들이 기대하는대로 동작하고 있다는 것을 보장하기 어려워질 수도 있다. 또 다른 단점으로는 구독자들이 서로의 존재에 대해 전혀 알 수 없고 발행자를 변경하는데 드는 비용을 파악할 수 없다는 점이다. 구독자와 발행자 사이의 관계가 동적으로 결정되기 때문에 어떤 구독자가 어떤 발행자에 의존하는지 추적하기 어려울 수 있다.


## 7.19 중재자 패턴
중재자(Mediator) 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴이다. 이 패턴의 특징은 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다는 점이다. 반면에 관찰자 패턴은 하나의 객체가 다른 객체에서 발생하는 다수의 이벤트를 구독할 수 있도록 한다.

### 7.19.2 유사점과 차이점
중재자 패턴과 이벤트 집합 패턴의 유사점은 '이벤트'와 '서드 파티 객체'라는 두 가지 핵심 요소로 요약할 수 있다.
<br /><br />
이벤트 <br />
이벤트 집합 패턴과 중재자 패턴 모두 이벤트를 사용한다. 다만 이 두 패턴이 왜 이벤트를 사용하는지에 대해 차이점이 존재한다. 이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다. 하지만 중재자 패턴은 단순히 편리하기 때문에 이벤트를 활용할 뿐이다.
<br /><br />
서드 파티 객체 <br />
설계상, 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드 파티 객체를 사용한다.이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 한다. 중재자 패턴 또한 다른 객체에 대한 서드 파티 객체이다. 차이점은 애플리케이션 로직과 워크플로가 어디에 구현되어이 있는지에 달려있다.<br />
이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 한다. 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체(소스)와 처리하는 객체(핸들러)에 직접 구현된다.<br />
중재자 패턴에서 비즈니스 로직과 워크플로는 중재자 내부에 집중된다. 이를 통해 워크플로와 프로세스를 캡슐화하고 여러 객체 사이를 조율해 시스템이 원하는 대로 동작하도록 한다. 

### 7.19.3 이벤트 집합 패턴의 활용
일반적으로 이벤트 집합 패턴은 직접적인 구독 관계가 많아질 경우 또는 전혀 관련없는 객체들 간의 소통이 필요할 때 사용된다. 또한 간적접인 관계를 가진 객체 간의 소통이 필요한 상황에서도 유용하게 활용된다.

### 7.19.4 중재자 패턴의 활용
중재자 패턴은 두 개 이상의 객체가 간접적인 관계를 가지고 있고 비즈니스 로직이나 워크플로에 따라 상호작용 및 조정이 필요한 경우에 유용하다. 중재자 패턴을 도입함으로써 개별 뷰 간의 직접 참조로 인한 강한 결합을 방지하고, 비즈니스 로직에 따른 워크플로를 명확하고 효율적으로 모델링할 수 있다. 

### 7.19.5 이벤트 집합 패턴(발행/구독)과 중재자 패턴 결합하기
메뉴 항목을 선택하는 것은 애플리케이션 전반에 걸쳐 연쇄적인 변화를 일으킬 수 있다. 일부 변화는 서로 독립적이므로 이벤트 집합 패턴을 사용하기 적합하다. 그러나 상호 연관성을 갖는 변화가 존재할 경우 중재자 패턴을 사용하여 구현하는 것이 적합하다.<br />
이벤트 집합 패턴과 중재자 패턴을 결합함으로써 코드와 애플리케이션 구현 양쪽에서 유의미한 사용자 경험을 만들어낼 수 있다. 이벤트 집합 패턴을 통해 메뉴와 워크플로 사이의 명확한 분리를 구현할 수 있고, 중재자 패턴을 통해 워크플로의 관리 및 유지보수성을 강화할 수 있다.

### 7.19.7 중재자 패턴 vs 퍼사드 패턴
중재자 패턴은 모듈이 명시적으로 중재자를 참조함으로써 모듈 간의 상호작용을 중앙집중화한다. 이는 본질적으로 다방향성을 지닌다. 반면에 퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지는 않는다. 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다.

## 7.20 커맨드 패턴
커맨드(Command) 패턴은 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해준다. 이를 통해 실행 시점을 유연하게 조정하고 호출을 매개변수화 할 수 있다. 또한 커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 향상시킨다.<br />
커맨드 패턴의 기본 원칙은 명령을 내리는 객체과 명령을 실행하는 객체의 책임을 분리한다는 것이다. 커맨드 패턴은 이러한 책임을 다른 객체에 위임함으로써 역할 분리를 실현한다. <br />
커맨드 패턴의 주요 장점은 인터페이스가 동일한 모든 커맨드 객체를 쉽게 교체할 수 있다는 점이다. 