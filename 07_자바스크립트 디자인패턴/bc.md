### 7.2 생성자 패턴
- 생성자는 객체가 새로 만들어진 뒤 초기화하는데 사용되는 특별한 메서드
- 클래스는 js가 가진 프로토타입의 상속을 이용한 문법적 설탕

### 7.2.1 객체 생성
- 3가지 방법
```javascript
const newObject= {}; // 1
const newObject= Object.create(Object.prototype); // 3
const newObject= new Object(); // 3
```
- 각 객체는 읽기 전용 상수로 선언(const)
	- 빈 객체를 생성하여 반환
- 객체에 키와 값을 할당.
1. Dot 문법
2. 대괄호 문법 // ECMAScript5 만 호환
3. Object,defineProperty
	- writable, enumerable, configuarable 속성 제어 가능

### 7.2.2 생성자의 기본 특징
- 클래스는 객체 템플릿을 정의하고 캡슐화 . 및상속을 구현
- 생성자 내부에서 사용된 this 키워드는 새로 생성된 객체
- 특정 유형의 인스턴스는 모두 동일한 함수를 공유해야하므로 효과적이지 않음


### 7.2.3 프로토타입을 가진 생성자
- js의 프로토타입 객체는 함수나 클래스 등의 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있게 함.
- 생성자를 통해 생성된 객체는 생성자으 프로토타입 객체에 속한 속성을 활용.

## 7.3 모듈 패턴
- 모듈은 어플리케이션의 핵심 구성 요소
- 프로젝트를 구성하는 코드 단위를 분리 및 관리하는데 효과적
- 모듈 구현 방법 종류
	- 객체 리터럴 표기법(Object Literal Notation)
	- 모듈 패턴
	- AMD 모듈
	- CommonJS 모듈

### 7.3.1 객체 리터럴
- 중괄호 안에서 키와 값을 구분하여 객체를 정의
```javascript
const myObjectLiteral = {
	variableKey: '~',
	functionKey() {}
}
```
- new 연산자 키워드가 필요하지않다.
- 객체 리터럴을 사용하면 코드를 캡슐화하여 깔끔하고 체계적으로 관리

### 7.3.2 모듈 패턴
- 클래스의 캡슐화를 위해 처음 고안

**비공개**
- 모듈패턴은 클로저(closure)를 활용해 `비공개` 상태와 구성을 캡슐화
- 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌 방지
	- 공개 API만 노출
	- 즉시 실행함수(IIFE)를 사용해 객체를 반환.
- ES2019이전 js에서는 접근제한자(#)를 지원하지 않아 비공개라는 개념이 존재하지않았음.
	- 클로저로 구현
- 반환된 객체에 포함된 변수를 비공개하려면 weakMap()을 사용
	- 객체만 키로 설정할 수 있으며 순회는 불가능
	-  객체에 접근하는 유일한 방법은 객체의 참조
- 메서드를 호출할 때에 이름을 지정(namespace) 해서 사용해야한다.

### 7.3.3 모듈 패턴의 변형

**믹스인 가져오기 변형**
- 유틸함수나 외부라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차함수에 인자로 전달.

**내보내기 변형**
- 따로 이름을 지정해주지 않고 전역스코프로 변수를 내보낸다.

#### 장점
- 믹스인 가져오기에서는 모듈사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하게 하고 독립적으로 만들어준다.
- 비공개 지원
	- export를 통해 바깥으로 노출한 값들만 접근 가능하게한다.
	- 전역 스코프 오염 방지
- 모듈을 공개하면 캡슐화 가능
	- 의존성을 동시에 사용가능
#### 단점
- 공개 비공개 멤버를 서로 다르게 접근
- 나중에 추가한 메서드에서는 비공개 멤버에 접근 불가능
- 자동화 테슽트에서 비공개멤버 테스트 제외

### 7.3.4 WeakMap을 사용한느 최신 모듈 패턴
- 참조되지않는 키는 GC대상이 됨.
- 키가 약하게 유지되는 Map

### 7.3.5 최신 라이브러리와 모듈
- 리액트같은 js라이브러리를 만들때 모듈패턴 사용

## 7.4 노출 모듈 패턴
- 크리스티안 하일만의 노출 모듈 패턴
- 공개변수나 메서드에 접근하기 위해 가져온 메인 객체 이름을 반복해서 사용한다는 단점에서 고안
- 모든 함수와 변수를 비공개 스코프에 정의하고 공개하고자하는 것만 포인터를 통해 공유
- ES2015+ 부터는 스코프안에 정의된 함수와 변수는 비공개

## 7.5 싱글톤 패턴
- 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴
- 전역에서 접근 미 공유해야하는 단 하나의 객체가 필요할 때 유용
- `ES2015+` 에서는 js클래스의 전역 인스턴스를 단 한번 생성하는 싱글톤 패턴을 구현 가능
- 공개된 get, set  메서드를 통해 인스턴스를 읽고 수정할 수 있다.
- 싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용
- GoF에서는 싱글톤 패턴적합성에 대해 언급
	- 인스턴스는 하나만 존재, 접근을 용이하게 해야함
	- 인스턴스는 서브 클리싱을 통해서만 확장
- 싱글톤에서 지연된 실행이 중요한 이유
	- 싱글톤과 정적클래스의 차이점을 아는 것이 중요
	- 싱글톤을 정적 인스턴스로 구현했다 하더라도 리소스나 메모리를 소모하지않도록
#### 단점
- 싱글톤임을 파악하는 것이 힘듬
- 테스트하기 어려움
	- 숨겨진 의존성, 여러 인스턴스 생성의 어려움 등으로 인해
- 신중한 조정이 필요
- 싱글톤의 사용하례로는 전역 범위에 걸쳐 데이터를 저장
	- 어플리케이션의 크기와 복잡성이 커짐에 따라 구현이 어려워질 수 있다.

### 7.5.1 리액트의 상태관리
- 싱글톤 대신 Redux와 같은 전역상태관리 도구 이용
	- 변경 불가능한 읽기 전용 상태 제공
- 전역 상태를 직접 변경할 수 없게 하여 전역상태가 의도한 대로 변경

## 7.6 프로토타입 패턴
- 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴
- 상속 기반
- 클래스처럼 따로 정의하는게 아니라, 이미 존재하는 다른 객체를 복제하여 새로운 객체를 만듬
- 성능에서 이점.
	- 객체내에 함수 정의할 때, 복사본이 아닌, 참조로 생성되어 모든 객체가 동일한 함수를 가리킴
	- (실행 컨텍스트 참고)

## 7.7 팩토리 패턴
- 객체를 생성하는 생성 패턴의 하나
- 생성자를 필요로 하지않는다.
- 동적인 요소나 어플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 사용

### 7.7.1 팩토리 패턴을 사용하면 좋은 상황
- 객체 컴포넌트의 생성과정이 높은 복잡성을 가질 때
- 상황에 맞추어 다양한 객체를 편리하게 생성할 때
- 같은 속성을 공유하는 여러개의 작은 객체 또는 컴포넌트를 다뤄야할 때
- duck typing같은 API규칙만 충족하면 되는 다른 객체와 함계 객체를 구성할 때

### 7.7.2 사용하면 안되는 상황
- 어플리케이션의 복잡성이 높아질 수 있음.
- 라이브러리나 프레임워크 설계 목표가 아니라면 위험을 피해 생성자가 좋을 수 있음??
- 추상화 되기 때문에 단위 테스트에서 어려울 수 있다.

### 7.7.3 추상 팩토리 패턴
- 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
- 객체의 생성 과정에서 영향을 받지 않아야함.
- 여러 타입 객체로 작업해야하는 경우 세부사항을 알 필요없이 객체를 사용
- 추상 타입으로 새로운 인스턴스를 생성

## 7.8 구조 패턴
- 퍼사드
- 믹스인
- 데코레이터
- 플라이웨이트

## 7.9 퍼사드(Facade) 패턴
- 퍼사드란 실제 모습을 숨기고 꾸며낸 겉모습을 드러내는 것
- 심층적인 복잡성을 숨기고 사용하기 편리한 높은 수준의 인터페이스를 제공
- jQuery 같은 js라이브러리에서 흔히 볼 수 있는 패턴
- 광범위한 기능을 갖고 있으면서도 제한된 추상화 메서드만이 공개되어 사용 가능

#### 장점
- 사용하기 쉬움
- 패턴구현에 필요한 코드 양이 적음

## 7.11 서브클래싱
- `ES2015+` 에서 도입된 기능을 통해 기존 또는 부모클래스를 확장 가능, 부모클래스의 메서드를 호출 가능(super)
- 서브클래싱이란, 
	- 부모클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것. (**메서드 체이닝**)
- 부모클래스의 생성자 호출 (**생성자 체이닝**)
```javascript
class A {
	constructor() {
		super(firstName, lastName); // 생성자 체이닝
	}
}
```


## 7.12 믹스인
- 최소한의 복잡성으로 객체의 기능을 빌리거나 상속할 수 있게 함.
- 다른 클래스를 아울러 쉽게 공유할 수 있는 속성과 메서드를 가진 클래스
- 려어 클래스의 기능을 섞은 것으로 문제를 해결

```javascript
const myMixins = superClass => 
	class extends superClass {
		moveUp() {}
		moveDown() {}
		stop() {}
	}

class MyAnimator extends MyMixins(CarAnimator) {}
```

### 7.12.1 장점과 단점
#### 장점
- 함수의 중복 기능을 중리고 재사용성을 높인다.
- 기능을 공유하여 중복을 피하고 고유의 기능을 구현하는데 집중

#### 단점
- 몇몇 개발자들은 클래스나 객체의 프로토타입에 기능을 주입하는 것을 나쁜 방법이라 여긴다.
	- 프로토타입 요염과 함수의 출처 불확실성
- 리액트에서 ES6 클래스 도입 이전 믹스인 사용
	- 컴포넌트의 유지보수와 재사용성이 복잡해짐

### 7.13 데코레이터 패턴
- 재사용을 목표로하는 구조 패턴
- 믹스인과 마찬가지로 객체 서브클래싱의 다른 방법
- 기존 클래스에 동적으로 기능을 추가하기 위해 사용
- 기존 시스템의 내부 코드를 힘겹게 바꾸지 않고도 기능을 추가할 수 있음.
- 서브클래싱 대신 베이스객체에 속성이나 메서드를 추가하여 간소화

## 7.14 의사클래스 데코레이터
- 인터페이스란 객체가 가져야할 메서드 정의 방법
- 메서드 구현방법에 대해 구체적 명시 X
- 메서드가 갖는 매개변수를 선택 O
- js 내장된 기능 X
	- ts 로 대체 가능해짐

### 7.14.2 추상 데코레이터
- 모든 조합의 서브클래스를 만드는 대신, 몇몇의 새로운 데코레이터를 만들자
- Object.prototype을 사용하여 새로운 메서드 추가 가능
- 모든 가능한 조합의 클래스를 따로 정의하지 않고도, 필요한 만큼의 데코레이터 만을 사용하여 베이스 클래스에 독립적으로 기능을 추가할 수 있게 해줌

## 7.15 장점과 단점
- 새로운 기능으로 감싸여 확정되거나 `데코레이트` 될 수 있으며 베이스 객체가 변경될 필요 없이 사용 가능
- 네임스페이스에 작고 비슷한 객체를 추가
	- 잘 관리되지 않으면 구조 복잡도 높아짐

## 7.16 플라이웨이트 패턴
- 반복되고 느리고, 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결 방법
- 연관된 객체끼리 데이터 공유ㅡ 메모리 최적화를 목적으로 함.

### 7.16.1 사용법
1. 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
2. DOM레이어에서도 적용 가능
	1. 비슷한 동작을 하는 이벤트 핸들러를 모든 자식 요소에 등록하기 보단 부모 요소같은 중앙 관리자에게 맡기는 방식

### 7.16.2 데이터 공유
#### 내재적 정보
- 객체의 내부 메서드에 필요한 것.
- 없으면 동작하지 않는다
- 인스턴스화 된 객체를 재사용하면 되기 때문에 객체의 내재적 정보가 다를 경우에만 새로운 객체 복사본을 생성
#### 외재적 정보
- 제거되어 외부에 저장 가능
- 외재적 정보를 다룰 땐 따로 관리자 사용
	- 플라이웨이트 객체와 내재적 상태를 보관하는 중앙 DB를 관리자로 사용

### 7.16.7 플라이웨이트 패턴과 DOM 객체
- DOM 은 topdown(이벤트 캡처링), bottom-up(이벤트 버블링) 두 가지 모두 지원

### 7.16.8 ex) 중앙 집중식 이벤트 핸들링
- 메뉴 그리고 리스트 기반의 위젯같은 것들을 설계할 때 부모 컨테이너 내부의 각 링크 요소에 클릭 이벤트를 바인딩하고 ㄴ한다.
```javascript
$('ul li a').on()
```
- 최상위 컨테이너에 플라이웨이트를 부착하여 하위 요소로 부터 전달되는 이벤트 감지 가능
- 개별적으로 관리되었던 동작을 하나의 동작으로 바꾸어 메모리 절약

## 7.18 관찰자 패턴 (Observer)
- 한 객체가 변경될 때, 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴
#### 구성요소
- 주체
	- 관찰자 리스트ㅡ를 관리하고, 추가 삭제가 가능
- 관찰자
	- 주체의 상태 변화알림을 감지하는 update 인터페이스를 제공
- 구체적 주체 (concrete Subject)
	- 상태변화에 대한 알림을 모든 관찰자에게 전달하고, concrete Observer의 상태를 저장
- 구체적 관찰자(Concrete Observer)
	- Concrete Subject의 참조를 저장하고, 관찰자의 Update인터페이스를 구현하여 주체의 상태변화와 관찰자의 상태변화가 일치할 수 있도록 함.

### 7.18.1 관찰자 패턴과 발행/구독 패턴의 차이점
- 실제 js환경에서는 발행/구독 패턴이라는 변형된 형태를 많이 사용
- 발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널을 둔다.
	- 어플리케이션에 특화된 이벤트를 정의, 구독자에게 필요한 값이 포함된커스텀 인자를 전달
- 시스템의 구성요소 간에 느슨한 결합을 도모
- 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을때 알림을 받게 됨.

## 7.19 중재자 패턴
- 하나의 객체가 이벤트 발생시, 다른 객체들에게 알림을 보낼 수 있는 디자인 패턴
- 발행/구독 또는 이벤트 집합(Event Aggregation)
	- 여러개의 이벤트 소스를 하나의 객체로 보내는 방법
- 컴퓨터 과학의 세게에서의 중재자는 `행위 디자인 패턴` 이며, 시스템의 여러 부분이 통신할 수 있는 통합 인터페이스를 제공
- 시스템의 구성 요소 사이에 직접적인 관계가 너무 많은 것 같다면 중앙 통제 프인트를 두어 모든 구성요소들이 이를 통해 간접 소통할 때가 된것
	- 구성요소간의 관계를 관리함으로써 직접 참조를 없애고 느슨한 결합을 가능하게 함.
	- 결합도를 낮추고 구성요소의 재사요을 높임
- DOM의 이벤트 버블링과 이벤트 위임을 예시로 들 수 있다.
- 중재자 패턴과 이벤트 집합 패턴의 구현이 비슷해 보일 수 있으나 두 패턴의 의미와 의도는 다름.

### 7.19.1 간단한 중재자 구현
- 여러 객체간의 상호작용(로직과 행동)을 조율하는 객체
- 다른 객체들의 행동과 입력에 따라 언제 어느 객체를 호출할지 결정
```javascript
const meditator = {} // 단순 객체 리터럴
```
- 중재자는 객체간의 워크플로를 제어
- 객체리터럴 이상의 복잡한 구조는 필요하지않음

- 중재자 객체는 여러 객체간의 워크플로를 처리
	- 관리 책임을 단일책임에 집중

### 7.19.2 유사점과 차이점
#### 유사점
- 이벤트와 서드파티객체라는 두 가지 핵심요소를 요약
- 이벤트
	- 이벤트 집합, 중재자 패턴 모두 이벤트를 사용
	- 중재자 패턴은 js 어플리케이션 구현을 단순화하기 위해 활용할 뿐
 - 이벤트 대신 중재자 객체에 대한 참조를 하위 객체에 전달 또는 콜백 메서드 사용

#### 서드파티 객체
- 이벤트 집합 패턴과 중재자 패턴 모두 상호작용을 간소화하기 위해 서드파티 객체를 사용
- 이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드파티 객체이며, 모든 이벤트가 통과하는 중앙허브 역할
- 이벤트 집합 패턴에서 서드파티 객체는 알 수 없는 수의 소스에서 알수 없는 수의 핸들러로 연결되도록 지원
	- 워크플로, 비즈니스 로직은 이벤트를 발생시키는 객체와 처리되는 핸들러에서 직접 구현
	- 중재자 패턴에서 비즈니스 로직과 워크플로는 중재자 내부에 집중
		- 이를 통해 워크플로 비즈니스 로직의 캡슐화
		- 중재자는 거시적인 차원에서의 결정을 통해 객체들에 적절한 작업 시기를 알려줌
	- 이벤트 집합 패턴은 `발행 후 망각` 방식의 소통 모델 사용
		- 객체는 구독자의 존재여부 상관없이 이벤트 발행 후 처리를 위임

### 7.19.3 이벤트 집합 패턴의 활용
- 직접적인 구독관계가 많아질 경우 또는 전혀 관련이 없는 객체들 간의 소통이 필요할 때, 사용
- ex
	1. 부모뷰와 자식뷰 같이 직접적인 관계가 존재하는 경우
	2. jQuery의 on() 메서드

## 7.20 커맨트 패턴
- 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 한다.
- 실행 시점을 유연하게 조정, 호출을 매개변수화 할 수 있다.
- 명령을 실행하는 객체와 호출하는 객체간의 결합을 느슨하게 하여 구체적인 클래스의 변경에 대한 유연성 향상
- 추상 클래스를 상속받아 필요한 기능을 모두 구현한 클래스를 구체 클래스(Concrete Class)라 한다.
