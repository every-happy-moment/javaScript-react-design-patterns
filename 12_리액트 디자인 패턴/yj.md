# 12_리액트 디자인 패턴

## 12.1 리액트 소개
리액트는 인터페이스를 표현하는 최적화 및 간소화된 방법을 제공한다. 인터페이스를 컴포넌트, Props, 상태라는 세 가지 핵심 개념으로 나누어 정리함으로써 복잡하고 까다로운 인터페이스를 쉽게 구출할 수 있다.

### 12.1.2 리액트의 기본 개념
- JSX<br />
JSX는 XML과 유사한 구문을 사용하여 HTML을 자바스크립트에서 사용할 수 있게 해주는 확장 문법이다.
- 컴포넌트 <br />
컴포넌트는 리액트의 기본 구성 요소이다. 어떠한 입력값(Props)을 받아서 화면에 표시할 내용을 나타내는 리액트의 요소를 반환하는 함수.
- Props <br />
리액트 컴포넌트의 내부 데이터를 의미한다. props 값은 컴포넌트가 만들어기 전에 미리 결정되고 컴포넌트 설계의 일부로 사용된다. props 값은 바꿀수 없다. 컴포넌트로 전달되고 나면 읽기 전용이 된다.
- 상태 <br />
컴포넌트의 라이프사이클 동안 값이 변할 수도 있는 정보를 담고 있는 객체이다. 또한 컴포넌트가 받아온 props의 현재 상태를 나타내기도 한다.
- 클라이언트 사이드 렌더링 <br />
클라이언트 사이드 렌더링(Client-Side Rendering(CSR))에서는 서버가 페이지의 기본 HTML 컨테이너만을 렌더링한다. 페이지에 내용을 표시하기 위해 필요한 로직, 데이터 가져오기, 템플릿, 라우팅은 클라이언트에서 실행되는 자바스크립트 코드가 처리한다. CSR은 SPA(Single Page Application)를 구축하는 방법으로 인기를 얻었다. 
- 서버 사이드 렌더링 <br />
서버 사이드 렌더링(Server-Side Rnedering(SSR))은 사용자 요청에 응답하여 페이지 콘텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성한다. 웹 콘텐츠를 렌더링하는 오래된 방법 중 하나.
- 하이드레이션 <br />
리액트는 현재의 DOM 노드를 검사하고, 해당 자바스크립트와 연결하여 활성화, 즉 하이드레이트 한다.

## 12.2 고차 컴포넌트
고차 컴포넌트(High-Order Component(HOC)) 패턴은 여러 컴포넌트에서 동일한 로직을 재사용하는 방법 중 하나이다. 이 패턴을 사용하면 애플리케이션 전체에서 컴포넌트 로직을 재사용할 수 있다.<br />
고차 컴포넌트는 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트이다. 고차 컴포넌트는 인자로 받은 컴포넌트에 추가 기능을 적용한 새로운 컴포넌트를 반환한다.

### 12.2.1 고차 컴포넌트 조합하기
때로는 여러 고차 컴포넌트를 조합하여 사용할 수도 있다. <br />
고차 컴포넌트 패턴은 다음과 같은 경우에 효과적이다.
- 애플리케이션 전체에 걸쳐 여러 컴포넌트에 동일한 동작을 적용해야 할 때
- 추가된 커스텀 로직 없이도 컴포넌트가 독립적으로 작동할 수 있을 때

### 12.2.2 장점
재사용하고자 하는 로직을 한 곳에 모아 관리할 수 있다. 로직을 한 곳에 집중시킴으로써 코드를 DRY하게 유지하고, 효과적으로 관심사를 분리할 수 있다.

### 12.2.3 단점
고차 컴포넌트가 대상 컴포넌트에 전달하는 props의 이름은 충돌을 일으킬 수 있다.
```javascript
function withStyles(Component){
    return props => {
        const style = {
            padding: '0.2rem',
            margin: '1rem',
            ...props.style
        }
        return <Component style={style} {...props} />
    }
};

const Button = () => <button style={{ color: 'red' }}>Click me!</button>
const StyledButton = withStyles(Button);
```
여러 고차 컴포넌트를 조합하여 사용하게 된다면 어떤 고차 컴포넌트가 어떤 props을 제공하는지 파악하기 어려울 수 있다. 이렇게 되면 디버깅과 애플리케이션 확장에 어려움이 생길 수 있다.

## 12.3 렌더링 Props 패턴
렌더링 Props 패턴은 컴포넌트를 재사용하는 또 다른 방법이다. 렌터링 prop는 JSX 요소를 반환하는 함수 값을 가지는 컴포넌트의 prop이다. 컴포넌트 자체는 렌더링 prop 외에는 아무것도 렌더링하지 않는다. 자신의 렌더링 로직을 구현하는 대신, 렌더링 prop을 호출한다. <br />
함수를 컴포넌트의 props로 전달하고 그 함수의 반환값을 렌더링하는 패턴.
```javascript
function Component(props){
    const data = {...};

    return props.render(data);
}

<Component render={data => <ChildComponent data={data} />}>
```

### 12.3.1 상태 끌어올리기
입력 컴포넌트가 자신의 상태를 다른 컴포넌트와 공유하려면, 상태를 필요로 하는 컴포넌트와 가장 가까운 공통 조상 컴포넌트로 끌어올려야 한다. 이것이 바로 상태 끌어올리기이다.<br />
작은 규모의 애플리케이션에서는 리덕스나 Context API와 같은 전역 상태 관리 라이브러리 대신 이 패턴을 사용하여 상태를 가장 가까운 공통 조상 컴포넌트로 끌어올리는 것만으로도 충분하다.<br />
하지만 큰 규모의 애플리케이션에서는 상태 끌어올리기가 복잡해질 수 있다. 각 상태 변경 시 데이터를 사용하지 않는 자식 컴포넌트까지 모두 리렌더링 될 수 있어, 성능에 악영향을 줄 수 있다. 그러나 렌더링 Props 패턴을 사용하면 이러한 문제를 해결할 수 있다. 

### 12.3.2 컴포넌트의 자식으로 함수 전달하기
일반적인 JSX 컴포넌트 외에도, 컴포넌트의 자식으로 함수를 전달할 수 있다. 이 함수는 children props을 통해 접근할 수 있으며, 엄밀히 말하면 렌더링 Props 패턴이기도 하다.
```javascript
export default function App(){
    return (
        <div className="App">
        <h1>Temperature Converter</h1>
        <Input>
            {
                (value) => (
                    <>
                    <Kelvin value={value} />
                    <Fahrenheit value={value} />
                    </>
                )
            }
        </Input>
        </div>
    );
}

function Input(props){
    const [value, setValue] = useState("");

    return(
        <>
        <input type="text" value={value} onChange={(e) => setValue(e.target.value)} placeholder="Temp in C" />
        {props.children(value)}
        </>
    )
}
```
Input 컴포넌트의 props.children을 통해 자식으로 전달된 함수에 접근할 수 있다. 이렇게 하면 렌더링 props의 이름에 구애받지 않고도 값에 접근할 수 있다.

### 12.3.3 장점
렌더링 Props 패턴을 사용하면 여러 컴포넌트 사이에서 로직과 데이터를 쉽게 공유할 수 있다. render 또는 children prop을 활용하여 컴포넌트의 재사용성을 높일 수 있다. 렌더링 Props 패턴은 고차 컴포넌트 패턴 사용시 발생할 수 있는 몇 가지 문제를 해결할 수 있다. 이름 충돌 문제를 해결할 수 있고 애플리케이션 로직과 렌더링 컴포넌트를 분리할 수 있다.

### 12.3.4 단점
리액트 Hooks는 대부분의 경우 렌더링 Props 패턴을 대체해 사용할 수 있다. 그리고 렌더링 prop에는 라이프사이클 관련 메서드를 추가할 수 없으므로, 받은 데이터를 변경할 필요가 없는 렌더링에 치중한 컴포넌트에만 사용할 수 있다.

## 12.4 리액트 Hooks 패턴
리액트 16.8 버전부터 Hooks라는 새로운 기능이 도입되었다. Hooks를 사용하면 ES2015 클래스 컴포넌트를 사용하지 않고도 상태와 라이프사이클 메서드를 활용할 수 있다. Hooks는 많은 전통적인 디자인 패턴을 대체할 수 있다.

### 12.4.1 클래스 컴포넌트
리액트에 Hooks가 도입되기 전에는, 컴포넌트에 상태와 라이프사이클 메서드를 추가하려면 클래스 컴포넌트를 사용해야만 했다. 클래스 컴포넌트는 다음과 같은 특징을 가지고 있다.
- 생성자 함수 내의 상태
- 컴포넌트의 라이프사이클에 따른 효과를 처리하기 위한 ComponentDidMount, componentWillUnmount 와 같은 라이프사이클 메서드
- 추가적인 로직을 구현하기 위한 커스텀 메서드

### 12.4.4 Hooks 
리액트 Hooks를 사용하면 다음과 같은 구현이 가능하다.
- 함수형 컴포넌트에 상태 추가하기
- ComponentDidMount, componentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기
- 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용하기

### 12.5.3 Hooks 관련 추가 정보
- useState <br />
useState Hook을 사용하면 함수형 컴포넌트 내에서 클래스 컴포넌트로 변환하지 않고도 상태를 업데이트하고 조작할 수 있다.
- useEffect <br />
useEffect Hook은 함수형 컴포넌트의 주요 라이프사이클 이벤트 중간에 코드를 실행하는 데 사용된다. 이 Hook 하나로 기존의 ComponentDidMount, ComponentDidUpdate, componentWillUnmount를 모두 한 번에 처리할 수 있다.
- useContext <br />
useContext Hook은 React.createContext로 만들 수 있는 context 객체를 인자로 받아 해당 context의 현재 상태에 접근할 수 있게 한다. 또한 Context API와 연동하여 props를 여러 단계에 걸쳐 전달하지 않고도 애플리케이션 전역에서 상태를 공유할 수 있다.
- useReducer <br />
useReducer Hook은 setState의 대안으로, 여러 깊은 트리를 가진 복잡한 상태 로직이나 변경 이후의 상태가 이전 상태에 따라 달라지는 경우에 특히 유용하다. 깊은 구조를 가진 컴포넌트의 업데이트 성능을 최적화한다.

### 12.5.4 Hook의 장단점
장점
- 더 적은 코드 라인수
- 복잡한 컴포넌트의 단순화
- 상태 관련 로직 재사용
- UI에서 분리된 로직 공유

단점
- Hook 사용 규칙을 준수해야 한다. 
- 올바르게 사용하려면 상당한 연습이 필요하다(예: useEffect).
- 잘못된 사용에 주의해야 한다(예: useCallback, useMemo).

## 12.6 정적 가져오기
import 키워드를 사용하면 다른 모듈에서 내보낸(export) 코드를 가져올 수 있다. 기본적으로 정적으로 가져오는 모든 모듈은 초기 번들에 추가된다. 

## 12.7 동적 가져오기
리액트의 Suspense 기능을 사용하여 동적으로 가져올 수 있다. Suspense 컴포넌트는 일시 중단된 컴포넌트가 로딩되는 동안에 대신 렌더링될 컴포넌트를 받는 fallback prop을 사용한다. <br />
초기 번들 크기가 작아지면 초기 로딩 속도가 빨라진다. 덕분에 사용자는 빈 로딩 화면을 오래 기다릴 필요가 없다. 또한 fallback prop 으로 넘겨진 컴포넌트는 애플리케이션이 멈춘 것이 아니라 모듈이 처리되고 실행될 때까지 잠시 기다려야 함을 사용자에게 알려준다.

### 12.7.1 로더블 컴포넌트
리액트 18부터는 SSR 환경에서도 Suspense를 사용할 수 있도록 기능이 추가되었다. 그 이전 버전에서는 Suspense 대신 loadable-components 라이브러리를 사용해야 한다.

### 12.7.2 상호작용 시 가져오기
사용자의 상호작용을 통해 컴포넌트 가져오기를 실행하는 것

### 12.7.3 화면에 보이는 순간 가져오기
컴포넌트가 사용자에게 보일 때 동적 가져오기를 실행하는 것을 '화면에 보이는 순간 가져오기(import on Visibility) 라고 한다. <br />
컴포넌트가 현재 화면에 표시되는지 확인하려면 IntersectionObserver API를 사용하거나, react-loadable-visibility 또는 react-lazyload 와 같은 라이브러리를 활용하여 애플리케이션이 보이는지에 따라 가져오는 기능을 쉽게 추가할 수 있다.

## 12.8 코드 스플리팅
### 12.8.1 경로 기반 분할
때로는 특정 페이지나 경로에서만 필요한 리소스가 있을 수 있다. 이런 경우, 경로 기반 분할(Route-based Splitting)을 통해 특정 경로에 필요한 리소스만 요청할 수 있다. Suspense 또는 loadable-components와 react-router 같은 라이브러리를 함께 사용하면, 현재 경로에 따라 컴포넌트를 동적으로 로드할 수 있다.

### 12.8.2 번들 분할
사용자에게 최대한 빨리 데이터를 보여주는 것은 중요하다. 번들의 크기가 커지만 로딩, 처리, 실행 시간이 모두 늘어나게 된다. 따라서 번들 크기를 줄여 속도를 높일 수 있다면 좋을 것이다. 그렇다면 불필요한 코드를 포함하는 거대한 번들 하나를 요청하는 대신, 번들을 여러 개의 작은 번들로 분할하는 방법을 사용할 수도 있다.<br />
초기 로딩 시 현재 페이지에서 우선순위가 높지 않은 코드를 요청할 때는 초기 페이지 렌더링에 필요한 코드와 분리해서 로드하는 것이 좋다.

## 12.9 PRPL 패턴
저사양 기기나 인터넷 연결이 불안정한 지역에서도 애플리케이션이 원활하게 작동하게 하기 위해서는 애플리케이션이 최대한 효율적으로 로드될 수 있도록 PRPL 패턴을 사용할 수 있다. <br />
PRPL 패턴은 다음 네 가지 핵심 성능 고려사항에 중점을 둔다.
- 푸시(Push): 중요한 리소스를 효율적으로 푸시하여 서버 왕복 횟수를 최소화하고 로딩 시간을 단축한다.
- 렌더링(Render): 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링한다.
- 사전 캐싱(Pre-cache): 자주 방문하는 경로의 에셋(asset)을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공한다. 서비스 워커(Service Worker) 사용.
- 지연 로딩(Lazy-load): 자주 요청되지 않는 경로나 에셋은 지연 로딩한다.

## 12.10 로딩 우선순위
로딩 우선순위 패턴은 필요하다고 예상되는 특정 리소스를 우선적으로 요청하도록 설정한다.<br />
Preload(<link rel="preload">)는 브라우저의 최적화 기능으로, 브라우저가 늦게 요청할 수도 있는 중요한 리소스를 더 일찍 요청할 수 있도록 한다. 하지만 preload가 만능은 아니며, 몇 가지 트레이드오프를 고려해야 한다.<br />
preload 사용시 주의해야 할 점은 상호작용에 필요한 리소스를 먼저 로딩하다가 FCP(First Contentful Paint) 또는 LCP(Largest Contentful Paint)에 필요한 리소스의 로딩이 지연되는 일은 피해야 한다는 것이다.<br />
만약 자바스크립트 자체의 로딩을 최적화하려면, `<body>` 태그보다는 `<head>` 태그 안에서 `<script defer>` 를 사용하는 것이 해당 리소스를 초기에 로딩하는데 도움이 될 수 있다.

## 12.11 리스트 가상화
리스트 가상화(List Virtualization)는 대규모 데이터 리스트의 렌더링 성능을 향상시키는 기술이다. 전체 목록을 모두 렌더링하는 대신 현재 화면에 보이는 행만 동적으로 렌더링한다. 렌더링 되는 행은 전체 목록의 일부이며, 사용자가 스크롤함에 따라 보이는 영역(윈도우)이 이동한다. 리액트에서는 react-virtualized 같은 라이브러리를 사용하여 구현할 수 있다.

### 12.11.4 웹 플렛폼의 발전
CSS의 content-visibility:auto 를 설정하면 화면 밖 콘텐츠의 렌더링과 페인팅을 필요한 시점까지 지연할 수 있다.<br />
동적인 콘텐츠 목록을 렌더링하는 경우에는 여전히 react-window와 같은 라이브러리를 사용하는 것이 좋다.