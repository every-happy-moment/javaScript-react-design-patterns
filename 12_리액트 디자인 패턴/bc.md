# 12장

React는 2013년에 처음 출시된 이후 지금까지 꾸준한 인기를 누리고 있는 라이브러리이다.

## 12.1 리액트 소개

FE 개발자들은 대부분 웹 인터페이스(버튼, 목록, 네비게이션 등과 같은 요소) 설계에 대해 관심이 많다. 리액트는 페이지나 뷰를 구성하기 전에 개별 컴포넌트를 먼저 개발하도록 하기에 각 컴포넌트의 역할과 목적을 확실히 할 수 있다. 이러한 과정을 `컴포넌트화한다` 라고 한다.

## 12.2 고차 컴포넌트

애플리케이션 내 여러 컴포넌트에서 동일한 로직을  사용하고 싶은 경우가 있다. 이러한 로직에는 컴포넌트에 특정한 스타일을 적용하거나 인증을 요구하거나, 전역상태를 추가하는 등이 포함될 수 있다. 고차 컴포넌트(HOC, High Order Component) 패턴은 여러 컴포넌트에서 동일한 로직을 재사용하는 방법 중 하나이다.

```jsx
function withStyles(Component) {
	return (props) => {
		const style = { padding: '0.2rem', margin '1rem' };
		return <Component style={style} {...props} />
	}
}

const Button = () => <button>Click me!</button>
const Text = () => <p>Hello World</p>

const StyledButton = withStyles(Button);
const StyledText = withStyles(Text);
```

위는 withStyles 고차 컴포넌트를 통해 추가된 스타일을 작성한 예제이다.

이와 유사한 구조로 로딩 이미지를 노출시키는 고차 컴포넌트를 활용한  DogImages 컴포넌트를 생성할 수 있다.

```jsx
function withLoader(Component url) {
	return (props) => {
		const [data, setData] = useState(null);
	
		useEffect(() => {
			async function getData() {
				// ...비동기 함수내부에서 데이터를 호출
			}
			getData();
		}, [])
		return <Component style={style} {...props} />
			
		if(!data) {
			return <div>Loading ...</div>
		}
		return <Component {...props} data={data} />
	}
}

function DogImages(props) {
	return props.data.message.map(() => {
		<img ... />
	})
}

export default withLoader(DogImages, 'https://url~~');
```

useEffect에서 데이터를 가져온다. 데이터를 가져오기 전까지 Loading... 문구롤 노출한다. withLoader의 함수 파라미터인 컴포넌트를 노출시킨다.


### 12.2.1 고차 컴포넌트 조합하기

여러 고차 컴포넌트를 조합하여 사용할 수 있다. DogImages 목록 위로 마우스 커서를 가져가면 텍스트 박스를 표시하는 기능을 추가한다고 가정해보자

컴포넌트에 마우스 호버링 props을 제공하는 고차 컴포넌트를 만들어야한다.
```jsx
export default withHover(
	withLoader(DogImages, 'https://url~~')
)
```

### 12.2.2 장점

고차 컴포넌트 패턴을 사용하면 재사용하고자하는 로직을 한 곳에 모아 관리할 수 있다. 또한, 버그를 퍼뜨릴 위험을 줄일 수 있다. 로직을 한 곳에 집중시킴으로써 코드를 DRY하게 유지하고 관심사를 분리할 수 있다.

### 12.2.3 단점

props의 이름은 충돌을 일으킬 수 있다. 따라서 해당 Component의 고유 props 이외의 다른 props를 사용하는 것을 권장한다. 예를 들어 style보단 sx 와 같이.

## 12.3 렌더링 Props 패턴

여러 컴포넌트가 동일한 데이터에 접근하거나 동일한 로직을 포함해야할 때, 컴포넌트 로직을 재사용하면 개발이 편리해진다.

```jsx
<Title render={() => <h1>Title!</h1>} />

const Title = props => props.render();
```

### 12.3.1 상태 끌어올리기

입력 컴포넌트가 자신의 상태 컴포넌트와 공유하려면, 상태를 필요로 하는 컴포넌트와 가장 가까운 공통 조상 컴포넌트로 끌어올려야한다. 이것을 `상태 끌어올리기` 라 한다.

작은 규모의 애플리케이션에서는 리덕스나 ContextAPI와 같은 전역 상태 관리 라이브러리 대신 이 패턴을 사용하여 상태를 가장 가까운 공통 조상 컴포넌트로 끌어올리는 것만으로도 충분하다

하지만, 큰 규모의 애플리케이션에서 상태 끌어올리기는 복잡해질 수 있다. 각 상태 변경 시, 데이터를 사용하지 않는 자식 컴포넌트까지 모두 리렌더링될 수 있어, 성능에 악영향을 줄 수 있다. 렌더링 패턴을 사용하면 이러한 문제를 해결할 수 있다.

```jsx
function Input(props) {
	const [value, setValue] = useState("");
	return (
		<>
			<input 
				type="text"
				value={value}
				onChange={(e) => setValue(e.target.value)}
			/>
			{props.render(value)}
		</>
	)
}

export default App() {
	return (
		<div>
			<Input 
				render={(value) => (
					<>
						<Kelvin value={value} />
						<Fahrenheit value={value} />
					</>
				)}
			/>
		</div>
	)

}
```


### 12.4 리액트 Hooks 패턴

리액트 16.8 버전부터 Hooks 라는 새로운 기능이 도입됐다. ES2015의 클래스 컴포넌트를 사용하지 않고도 상태와 라이프사이클 메서드를 활용할 수 있다. Hooks 자체를 디자인 패턴이라고 할수는 없지만, 설계에서 중요한 역할을 한다.

### 12.4.2 구조 변경의 필요성

여러 컴포넌트 간에 코드를 공유하는 일반적인 방법은 고차 컴포넌트 또는 렌더링 Props 패턴을 사용하는 것이다. 나중에 패턴을 추가하게 되면 애플리케이션의 구조를 변경해야하는 번거로움이 있다.

래퍼헬: 깊게 중첩된 컴포넌트간에 코드를 공유하기 위해 여러 겹의 컴포넌트를 사용하게 되는 구조

### 12.4.3 복잡성 증가

클래스 컴포넌트에 더 많은 로직을 추가할 수록 컴포넌트의 크기는 빠르게 증가한다. 개발자는 특정 로직이 클래스 컴포넌트의 어디에서 사용되는지 이해하기 어려워진다.

### 12.4.4 Hooks

컴포넌트의 상태와 라이프사이클 메서드를 관리할 때 사용할 수 있는 함수이다. 사용하게 되면 다음과 같은 구현이 가능하다.

- 함수형 컴포넌트에 상태 추가하기
- componentDidMount, ComponentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기
- 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용하기

### 12.5 상태 Hook

함수형 컴포넌트 내에서 상태를 관리하는 useState Hook 제공한다.


### 12.5.1 이펙트 Hook

useEffect Hook을 사용하면 컴포넌트의 라이프사이클에 접근할 수 있다. componentDidMount, componentDidUpdate, component WillUnmount 라이프사이클 메서드를 하나로 합쳐 사용할 수있다.


```jsx
componentDidMount() { ... }
useEffect(() => {}, [])

componentWillUnmount() { ... }
useEffect(() => { return () => {} }, []) // cleanup 동작

componentDidUpdate() { ... }
useEffect(() => {}, [ ... ])
```


### 12.6 정적 가져오기

ES2015+ 의 기본 import 문법인 import module from 'module'을 사용하여 가져오는 모듈은 모두 정적으로 가져온 것이다.

소스코드는 main.bundle.js 라는 하나의 번들로 묶인다. 이렇게 큰 번들은 사용자의 기기와 네트워크 환경에 따라 애플리케이션 로딩 시간에 큰 영향을 미칠 수 있다. App 컴포넌트가 사용자 화면에 내용을 렌더링하려면 먼저 모든 모듈을 로드하고 파싱해야하기 때문이다.(CSR 특징)

### 12.7 동적 가져오기

컴포넌트가 무거워짐에 따라 번들 사이즈가 커지게 된다. 이로 인해 잠재적인 로딩 시간이 증가할 수 있는 문제점이 존재한다. 이러한 문제를 해결하기 위해 컴포넌트를 동적으로 가져올 수 있다. 리액트의 Suspense 기능을 사용한다면 손쉽게 동적으로 가져올 수 있다.

Suspense로 불러오는 컴포넌트를 감싸게 되면 컴포넌트의 모듈 가져오기를 일시적으로 중단시킴으로써 App 컴포넌트가 더 빠르게 내용을 렌더링할 수 있도록 해준다. 일시 중단된 컴포넌트가 로딩되는 동안에 대신 렌더링될 컴포넌트를 받는 fallback props을 사용한다.

### 12.7.1 로더블 컴포넌트

SSR 환경은 아직 Suspense를 지원하지 않는다. SSR 애플리케이션에서 Suspense 대신 사용할 수 있는 대안으로는 loadable-components 라이브러리가 있다.

### 12.7.2 상호작용 시 가져오기

클릭할 때 컴포넌트를 동적으로 가져온다. 이런 유형의 동적 가져오기를 `상호작용 시 가져오기` 라고 한다. 사용자의 상호작용을 통해 컴포넌트의 가져오기를 실행한 것이다.

### 12.7.3 화면에 보이는 순간 가져오기

컴포넌트가 현재 화면에 표시되는지 확인하려면 IntersectionObserver API를 사용하거나 라이브러리(react-loadable-visibility 또는 react-lazyload)를 활용하여 기능을 쉽게 추가할 수 있다.

## 12.8 코드 스플리팅

여러 경로(Route)와 컴포넌트로 구성된 복잡한 애플리케이션에서는 적절한 시기에 정적 및 동적 임포트가 모두 가능하도록 코드를 최적으로 스플리팅하고 번들링 해야한다. 이를 위해 경로기반 분할을 사용하거나 웹백, vite 등 번들러를 사용하여 분할하고 번들링할 수 있다.

### 12.8.1 경로 기반 분할

특정 페이지나 경로에서만 필요한 리소스가 있을 수 있다. 이러한 경우 경로 기반 분할을 통해 필요한 리소스만 요청할 수 있다. Suspense 또는 loadable-components 와 react-router 같은 라이브러리를 함께 사용한다면 경로에 따라 컴포넌트를 동적으로 로드할 수 있다.


### 12.8.2 번들 분할

웹팩 또는 롤업과 같은 번들러는 애플리케이션의 소스 코드를 하나 이상의 번들 파일로 묶는다. 사용자가 웹사이트를 방문하면 필요한 데이터와 기능을 표시하기 위한 특정 번들이 요청되고 로드된다.

V8과 같은 JS은 사용자가 요청한 데이터를 로드하면서 동시에 파싱 및 컴파일할 수 있다. 최신 브라우저는 코드를 최대한 빠르고 효율적으로 파싱하고 컴파일하고도록 발전했지만, 요청된 데이터의 로딩 및 실행 시간 최적화는 여전히 개발자의 몫이다. 따라서, 메인스레드를 차단하지 않도록 실행 시간을 최대한 단축해야한다.

번들이 클수록 엔진이 첫번째 렌더링호출(FCP)을 하는데 까지 시간이 오래걸린다. 그때까지 사용자는 빈 화면을 봐야하므로 불편함을 느낄 수 있다.

번들 크기를 결정할 때 고려해야할 중요한 지표

- 첫번째 컨텐츠가 사용자 화면에 표시돠는 시간(FCP)
- 가장 큰 컨텐츠가 화면에 렌더링되는 시간(LCP)
- 모든 컨텐츠가 화면에 포시되고 인터랙티브해지는데 걸리는 시간(TTI, Time To Interaction)


### PRPL 패턴

저사양 기기나 인터넷 연결이 불안정한 지역에서도 애플리케이션이 원활하게 작동해야한다. 
PRPL 패턴은 네가지 핵심 성능 고려사항에 중점을 둔다.
- Push: 중요한 리소스를 효율적으로 푸시하여 서버 왕복횟수를 최소화하고 로딩시간을 단축한다.
- Render: 사용자 경험을 개선하기 위해 초기 경로를 최대한 빠르게 렌더링한다.
- Pre-cache: 자주 방문하는 경로의 에셋을 백그라운드에서 미리 캐싱하여 서버 요청 횟수를 줄이고 더 나은 오프라인 경험을 제공한다
- Lazy-load: 자주 요청되지않는 경로나 에셋은 지연로딩한다.

웹사이트를 방문하면 브라우저는 서버에 필요한 리소스를 요청한다. 애플리케이션의 초기 HTML 파일인데, 서버는 해당 파일의 진입점을 보내준다. HTML 파서는 서버로부터 데이터를 받는 즉시 파싱을 시작한다. 파싱 중에 스타일 시트나 스크립트와 같은 추가 리소스가 필요하다고 판단되면, 파싱을 중단하고 해당 리소스를 가져오기 위해 서버에 추가 HTTP 요청을 보낸다.

이러한 동작은 비효율적이다. 클라와 서버간 왕복횟수를 최소화 하는 것이 우리의 목표이다.

#### HTTP/1.1
- 요청과 응답에 줄바꿈문자로 구분되는 일반 텍스트(plaintext) 프로토콜을 사용.
- 헤더와 본문 필드를 포함하는 HTTP 요청은 최소 두 개의 프레임으로 나뉘는데, 하나는 헤더 프레임이고 다른 하나는 데이터 프레임
- 클라와 서버간에 최대 6개의 TCP 연결만 가능.
- TCP 연결을 통해 새로운 요청을 보내려면 이전 요청이 완료되어야 가능
	- 요청이 완료되는데까지 오래걸리는 경우 다른 요청을 보낼 수 없는 현상이 발생. 이러한 문제를 HOL(Head Of Line) Blocking 이라고 하며, 특정 리소스의 로딩 시간을 증가시킬 수 있는 단점

- HTTP/2 양방향(bidirectional)스트림을 사용.
- 단일 TCP연결을 통해 여러 개의 양방향 스트림을 만들어 클라와 서버간에 여러 개의 요청 및 응답 프레임을 동시에 전달할 수 있다.
- 서버는 특정 요청에 대한 모든 요청 프레인ㅁ을 받으면 이를 재조립 하여 응답 프레임을 생성(encapsulation, decapsulation)
- HOL Blocking 문제 해결
- 서버푸시(Server Push)라는 더욱 최적화된 데이터 가져오기 방식을 도입
	- HTTP 요청을 통해 매번 명시적으로 리소스를 요청하는 대신, 서버가 이러한 리소스를 푸시하여 자동으로 추가 리소스를 전송할 수 있게 된것.
- 클라가 추가 리소스를 받으면 해당 리소스는 브라우저 캐시에 저장
	- 캐시에서 빠르게 리소스를 가져올 수 있음

리소스 푸시는 추가 리소스를 받는 시간을 줄여주지만, 서버 푸시는 HTTP 캐시를 인지하지 못한다. 따라서 푸시된 리소스는 다음에 웹사이트 재방문 시에는 사용할 수 없고, 다시 서버에 요청해야한다. PRPL패턴은 초기 로드 이후 서비스 워커를 사용하여 해당 리소스를 캐시함으로써 클라가 불필요한 요청을 하지 않도록 한다.

중요한 리소스에 preload 힌트를 추가하여 브라우저가 가져와야할 리소스의 우선순위를 세우는데 도울 수 있다.
특정 리소스에를 미리 preload하도록 알려주면 더 빨리 가져오게된다. 중요한 리소스를 로드하는데 걸리는 시간을 최적화하는 좋은 방법이다.

주의할 점은 너무 많은 파일을 푸시하면 오히려 해가 될 수 있다. 브라우저 캐시는 제한적이며, 필요로 하지않는 리소스를 요청하여 불필요하게 대역폭을 많이 사용할 수 있다. PRPL 패턴은 초기 로딩 최적화에 중점을 두기에 초기 접근 경로가 완전히 렌더링 되기 전에는 다른 리소스를 로드하지 않는다.

코드 스플리팅을 활용한 번들은 사용자가 필요한 시점에 필요한 리소스만 로드하면서 캐시 활용도를 극대화할 수 있다. 여러번들이 동일한 리소스 대역폭을 공유할 수 있기 때문에 큰 번들을 캐싱하는 것은 문제가 될 수 있다.
따라서 최소한의 리소스만 포함하고 브라우저에서 리소스를 캐싱할 수 있도록 해야한다.

HTTP/2 서버 푸시를 지원하지않는 브라우저의 경우라면 왕복횟수를 최소화하는 최적화된 빌드를 생성하면된다.

PRPL패턴은 주로 애플리케이션 셸(Shell)을 주요 진입점으로 사용한다. 셸은 애플리케이션 로직의 대부분을 포함하며 여러 경로에서 공유되는 최소한의 파일이다.

PRPL 패턴은 초기 접근 경로의 화면이 사용자 기기에 표시되기 전에 다른 리소스가 요청되거나 렌더링되지 않도록 보장한다. 초기 경로가 성공적으로 로드되면 서비스 워커가 설치되어 자주 방문하는 다른 경로의 리소스를 백그라운드에서 가져온다.

따라서 사용자는 어떠한 지연이나 로딩도 느낄 수 없다. 서비스 워커에 의해 캐시된 경로로 이동하려는 경우, 서비스 워커는 서버에 요청을 보내는 대신, 캐시에서 리소스를 빠르게 가져와 사용자에게 리소스를 빠르게 보여준다.


