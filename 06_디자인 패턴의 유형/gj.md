# 06. 디자인 패턴의 유형

디자인 패턴의 세 가지 주요 유형과 각 유형에 속하는 다양한 패턴들에 대해 설명한다.

## 6.1 배경

> 'GoF의 디자인 패턴' 에서 디자인 패턴에 대해 설명

디자인 패턴은 어떤 문제를 해결하느냐에 따라 세 가지 유형으로 분류된다.

- 생성 패턴
- 구조 패턴
- 행위 패턴

## 6.2 생성 패턴

**생성 패턴**은 주어진 상황에 적합한 객체를 생성하는 방법에 중점을 둔다.

> 생성자(Constructor), 팩토리(Factory), 추상(Abstract), 프로토타입(Prototype), 싱글톤(Singleton), 빌더(Builder) 패턴

## 6.3 구조 패턴

**구조 패턴**은 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점을 둔다.

> 데코레이터(Decorator), 퍼사드(Facade), 플라이웨이트(Flyweight), 어댑터(Adapter), 프록시(Proxy) 패턴

## 6.4 행위 패턴

**행위 패턴**은 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점을 둔다.

> 이터레이터(Iterator), 중재자(Mediator), 관찰자(Observer), 방문자(Visitor) 패턴

## 6.5 디자인 패턴의 분류

| 생성 패턴                         |                      객체 생성의 기반이 되는 개념                       |
| --------------------------------- | :---------------------------------------------------------------------: |
|                                   |                                 클래스                                  |
| `팩토리 메서드(Factory method)`   |              인터페이스를 기반으로 여러 파생 클래스를 생성              |
|                                   |                                  객체                                   |
| `추상 팩토리(Abstractor Factory)` | 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스를 생성 |
| `빌더(Builder)`                   |    객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체를 생성    |
| `프로토타입`                      |               복사 또는 복제에 사용되는 초기화된 인스턴스               |
| `싱글톤(Singleton)`               |          전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스           |

| 구조 패턴             |                 객체 구조의 기반이 되는 개념                 |
| --------------------- | :----------------------------------------------------------: |
|                       |                            클래스                            |
| `어댑터(Adaptor)`     |  호환되지 않는 인터페이스가 상호자굥ㅇ하도록 클래스를 매치   |
|                       |                             객체                             |
| `브릿지(Bridge)`      |     객체의 인터페이수와 구현을 분리하여 독립적으로 구성      |
| `컴포지트(Composite)` | 단순히 합친 상태 이상의 효율을 내는 간단하면서 복합적인 구조 |
| `데코레이터`          |            객체에 새로운 프로세스를 동적으로 추가            |
| `퍼사드`              |        전체 시스템의 복잡한 부분을 숨기는 단일 클래스        |
| `플라이웨이트`        |      여러 객체에 공통 상태를 공유하는 세분화된 인스턴스      |
| `프록시`              |                  실제 객체를 대신하는 객체                   |

| 행위 패턴                            |                        객체 상호작용의 기반이 되는 개념                        |
| ------------------------------------ | :----------------------------------------------------------------------------: |
|                                      |                                     클래스                                     |
| `인터프리터(Interpreter)`            |           언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 방법            |
| `템플릿 메서드(Template method)`     |    상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의     |
|                                      |                                      객체                                      |
| `책임 연쇄(Chain of responsibility)` |          요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달          |
| `커맨드(Command)`                    |                      호출 부분과 실행 부분을 나누는 방법                       |
| `이터레이터`                         |                   내부 구조를 모른 채 요소에 순차적으로 접근                   |
| `중재자`                             | 클래스가 서로를 직접적으로 참조하지 않도록 중간에 간소화된 커뮤니케이션을 정의 |
| `메멘토(Memento)`                    |                나중에 복구할 수 있도록 객체의 내부 상태를 저장                 |
| `관찰자`                             |    클래스 간의 일관성을 보장하기 위해 여러 클래스에 변경사항을 알리는 방법     |
| `상태(State)`                        |                       상태가 변경되면 객체의 행위도 변경                       |
| `전략(Strategy)`                     |    클래스 내부에 알고리즘 구현을 캡슐화하여 상황에 따른 선택과 구현을 분리     |
| `방문자`                             |                  클래스를 변경하지 않고도 새로운 작업을 추가                   |
